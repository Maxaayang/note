初始化：创建变量时赋予其一个初始值
赋值：将变量的当前值擦除掉，以一个新的值来替代

列表初始化
```C++
int units_sold = {0};      
int units_sold{0};
```
如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
```C++
long double ld = 3.1415926536;
int a{ld}, b = {ld};     // 错误:转换未执行，因为存在丢失信息的危险
```

定义于函数内部的内部类型变量不被初始化。
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：`extern int i;    //声明而非定义 i`

引用本身不是一个对象，所以不能定义引用的引用。
引用只能绑定在对象上，不能与字面值或某个表达式结果绑定在一起。
常量引用可以绑定在非常量的对象、字面值、甚至是一个表达式。
常量引用一个其他类型的非常量时会产生一个中间的临时量对象。
如果常量引用一个非常量的对象，则不允许通过常量引用修改非常量的值。

指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
指针无须在定义时赋初值。
引用不是对象，没有实际地址，所以不能定义指向引用的指针。
nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。
不能直接操作 `void＊` 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。
存放常量对象的地址，只能使用指向常量的指针。
指向常量的指针也可以指向非常量。
**顶层 const**：指针本身是一个常量。
**底层 const**：指针所指的对象是一个常量。

指向指针的引用
```C++
int i = 42;
int ＊p;    // p是一个int型指针      
int ＊&r = p;     // r是一个对指针p的引用
```

如何只在一个文件中定义const，而在其他多个文件中声明并使用它？
对于const变量不管是声明还是定义都添加extern关键字。

常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。
**constexpr**：由编译器验证一个变量是否是一个常量表达式。
一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。
* 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。
* 定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。
在`constexpr`声明中如果定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的对象无关。

类型别名：
```C++
typedef double wages;    //wages是double的同义词
typedef wages base, ＊p;  //base是double的同义词，p是double＊的同义词
using SI = Sales_item;   // SI是Sales_item的同义词
```

`auto`一般会忽略顶层`const`。
设置一个类型为`auto`的引用时，初始值中的顶层常量属性仍然保留。

`decltype`：选择并返回操作数的数据类型。
如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）
`decltype((variable))`（注意是双层括号）的结果永远是引用，而 `decltype(variable)` 结果只有当 variable本身就是一个引用时才是引用。

