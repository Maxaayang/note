一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。
虽然某些表达式的求值结果是对象，但它们是右值而非左值。
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

* 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。
* 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
* 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
* 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。

左值：有名字的变量
右值：由运算操作所产生的中间结果
对于基础类型，右值是不可被修改的，也不可被 const, volatile 所修饰
对于自定义的类型，右值却允许通过它的成员函数进行修改。

**复合表达式**
对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生==未定义的行为==。
```C++
int i = 0;
cout << i << " " << ++i << endl; // 未定义的，其结果可能是1 1，也可能是0 1
```
**如何处理复合表达式**
* 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
* 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时第二条规则无效。

![[Pasted image 20220119095933.png]]
一元运算符优先级最高，其次是乘法、除法、求余，加减法优先级最低。
参与取余运算的两个对象必须是整数。
商一律向 0 取整。

**逻辑与关系运算符**
![[Pasted image 20220119100632.png]]
==短路求值==：只有当左侧的运算对象无法确定结果时才会计算右侧运算对象的值。

赋值运算符的左侧必须是一个可修改的左值。
如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间。
赋值运算符满足右结合律。
赋值运算符的==优先级较低==，所以通常要加上括号来满足意愿。

**递增递减运算符**
前置版本将对象本身作为左值返回，后置版本将对象的原始值的副本作为右值返回。
==除非必须，否则不要使用后置版本==：后置版本需要将原始值存储下来以便于返回这个未修改的内容。

解引用运算符的优先级低于点运算符。
箭头运算符作用于一个指针类型的运算对象，结果是一个左值。
点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。

**条件运算符（？：）**
当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。
条件运算符满足==右结合律==，意味着运算对象（一般）按照从右向左的顺序组合。
条件运算符的==优先级非常低==，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。

**位运算符**
![[Pasted image 20220119103503.png]]
关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。
将经过移动的左侧运算对象的==拷贝==作为求值结果。
右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移（<<）或者向右移（>>），移出边界之外的位就被舍弃掉了。
右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

==移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。==

sizeof运算符满足==右结合律==，其所得的值是一个 ==size_t== 类型的常量表达式。
sizeof 的优先级与 * 相同。
sizeof 运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。
sizeof运算不会把数组转换成指针来处理。
对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

**隐式类型转换：**
* 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
* 在条件中，非布尔值转换成布尔类型。
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
* 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。

运算符的运算对象将转换成最宽的类型。
当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。

当数组被用作 decltype 关键字的参数，或者作为取地址符（&）、sizeof 及 typeid 等运算符的运算对象时，数组不会转换成指针。
如果用一个引用来初始化数组，数组也不会转换成指针。

**命名的强制类型转换**
1. `static_cast`
任何具有明确定义的类型转换，只要不包含底层 `const`，都可以使用 `static_cast`
将一种类型转换为另一种类型。

```C++
void＊ p = &d;    // 正确：任何非常量对象的地址都能存入void＊
//正确：将void＊转换回初始的指针类型        
double ＊dp = static_cast<double＊>(p);
```

2. `const_cast`
只能改变运算对象的底层 `const`，`const_cast` 只改变常量属性。

3. `reinterpret_cast`
通常为运算对象的位模式提供较低层次上的重新解释。

**运算符优先级表**
![[Pasted image 20220119112218.png]]
![[Pasted image 20220119112238.png]]


