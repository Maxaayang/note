- 通过数据抽象，可以将类的接口与实现分离。
- 使用继承，可以定义相似的类型并对其相似关系进行建模。
- 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象


==继承==
- 如果基类希望派生类定义自己的版本，基类就会声明为==虚函数==。
- 派生类必须使用**类派生列表**指出它是从哪个基类继承而来的。
- 派生类必须在其内部对所有重新定义的虚函数进行声明，派生类可以在这样的函数之前加上 virtual 关键字，但不是必须的。

==动态绑定==
当使用基类的引用(或指针)调用一个虚函数时，将发生动态绑定，并且只会在这个时候发生。

# 基类与派生类
## 基类
基类通常应该定义一个虚析构函数，即使该函数不执行任何的实际操作也是如此。(==Why==)

virtual 只能出现在类内部的声明语句中，而不能用于类外部的函数定义。
如果在基类中一个函数是虚函数，那么在派生类中也是隐式的虚函数。
成员函数如果没有被声明为虚函数，那么其解析过程就发生在编译时而不是运行时。

如果基类希望派生类有权访问成员，而禁止其他用户访问，可以使用==protected==。

## 派生类
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

如果派生类想要显式的注明它将使用哪个成员函数来改写基类的==虚函数==，可以在该函数的形参列表之后、或者在 const 成员函数的 const 关键字后面、或者在引用成员函数的引用限定符后面增加一个 ==override== 关键字。==如果使用了 override，但是没有覆盖虚函数，编译器将报错。==
在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

==基类与派生类相同的部分可以相互转换==
因为在派生类对象中含有与其基类对应的组成部分，所以我们可以把派生类的对象当成基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。
智能指针类也支持派生类向基类类型的转换，这样就可以将一个派生类对象的指针存储在一个基类的智能指针内。

>[!note]
>- 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。
>- 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
>- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换，反之，如果D继承B的方式是私有的，则不能使用。

>[!faq] 为什么可以将基类的指针或引用绑定到派生类对象上？
>当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

>[!faq] 为什么不存在从基类到派生类的隐式类型转换？
>一个基类的对象既可以作为派生类对象的一部分存在，以为可以以独立的形式存在，如果不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。
>如果可以转换的话，就可能使用派生类的对象访问基类中不存在的成员。

派生类向基类的自动类型转换只对指针或引用有效。
当给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，该构造函数只能处理基类自己的成员，派生类的部分将被忽略掉。

==派生类不能直接初始化基类的成员==，必须使用基类的构造函数来初始化它的基类部分。
应该首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

>[!faq] 为什么基类必须是已经定义的，而不是仅仅被声明？
>- 派生类中保函并且可以使用它从基类中继承而来的成员，为了使用这些成员，派生类需要知道它们是什么。
>- 一个类不能派生它本身。

如何防止一个类被继承？
在类名之后跟一个关键字 ==final==

# 虚函数
==为什么虚函数必须有定义？==
虚函数必须有定义，不管它是否被用到了。因为我们直到运行时才能知道到底使用了哪个版本的虚函数，并且编译器也无法确定会使用哪个虚函数。

如果派生类的函数覆盖了某个继承而来的虚函数，则它的==形参类型==必须与被它覆盖的基类函数==完全一致==，返回类型也必须完全一致，除非虚函数的返回类型是类本身的指针或引用时，上述规则无效。

派生类如果定义了一个函数与基类中的虚函数的名字相同但是形参列表不同，编译器将认为新定义的函数以基类中原有的函数是相互独立的。

>[!faq] 如何确定派生类中的一个函数是否覆盖了基类中的一个虚函数？
>使用 ==override==，如果使用了 override，但是没有覆盖虚函数，编译器将报错。

如何强迫执行虚函数的某个特定版本？
使用作用域运算符。
```C++
double undiscounted = baseP->Qupte::net_price(42);
```
通常只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制。

>[!faq] 什么时候需要回避虚函数的默认机制？
>通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。


# 抽象基类

纯虚函数，在虚函数的函数体位置(即声明语句的分号之前)写一个 =0，=0 只能出现在类内部的虚函数声明语句处。
`double net_price(std::size_t) const = 0`

纯虚函数也可以有函数体，但是函数体必须定义在类的外部。

**抽象基类**：含有(或者未经覆盖直接继承)纯虚函数的类。

不能创建抽象基类的对象，但是可以创建抽象基类的派生类的派生类的对象，前提是覆盖了抽象基类的纯虚函数。

# 访问与继承

派生类的成员或友元只能通过派生类对象来访问基类的受保护的成员，对于一个基类对象中的受保护的成员没有任何访问权限。

友元的关系不能被继承。

==如何改变个别成员的可访问性？== ^0908e4
```C++
class Base {
public:
	std::size_t size() const { return n;}

protected:
	std::size_t n;
};

class Derived : private Base {
public:
	using Base::size;

protected:
	using Base::n;
}
```
Derived是私有继承的Base，但是所有的成员都可以访问size，派生类可以使用n。


当存在继承关系时，==派生类的作用域嵌套在其基类的作用域之内==。

派生类的成员可以隐藏同名的基类成员，但是我们可以通过作用域运算符来使用一个被隐藏的基类成员。
声明在内层作用域的函数并不会重载声明在外层作用域的函数，只是将其进行了隐藏。

>[!faq] 为什么基类与派生类中的虚函数必须有相同的形参列表？
>如果基类与派生类的虚函数接受的实参不同，就无法通过基类的引用或者指针调用派生类的虚函数了，因为会将其进行隐藏。

如果派生类希望所有的重载版本对于它来说都是可见的，那就需要覆盖所有的版本，或者一个也不覆盖，但是有时候一个类仅需要覆盖重载集合中的一些而非全部的函数，这时候可以==使用[[Sec_15 面向对象程序设计#^0908e4|using]]声明语句==，一条基类成员的using语句就可以将该函数的所有重载实例添加到派生类作用域当中。


# 构造函数与拷贝控制
当 delete 一个动态分配的对象时，如果指针指向的是继承体系中的某个类型，就有可能会出现指针的静态类型与被删除对象的动态类型不符的情况，从而产生未定义的行为。
通过在基类中==将析构函数定义成虚函数==可以确保执行正确的析构函数版本。

如果一个类需要析构函数，那它同样也需要开背与赋值操作，但是==基类的析构函数是不遵循这个规则的。==

虚析构函数将阻止合成移动操作，如果定义了一个析构函数，即使通过 `=default` 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

派生类析构函数只负责销毁由派生类自己分配的资源。
派生类的析构函数除了销毁派生类自己的成员外，还会负责销毁派生类的直接基类，而直接基类又会销毁它自己的直接基类，直至继承链的顶端。

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的而函数或者不可访问，则派生类中对应的成员将是被删除的，因为编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
- 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
- 当使用 `=default` 请求一个移动操作时，如果基类中的对于操作是删除的或不可访问的，那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动；如果基类的析构函数是删除的或者不可访问的，则派生类的移动构造函数也将是被删除的。


默认情况下，基类不含有合成的移动操作，如果定义了自己的移动操作，那么就必须同时显式地定义拷贝操作。


类只会继承其直接基类的构造函数，不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们。
派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的 `using` 声明语句。
对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。





















