本地变量所需的内存在栈上，和函数执行所需的其他数据在一起，当函数执行完之后，这些内存就释放了

栈上的内存
- 分配只需要移动一下栈指针
- 释放只需要在函数结束时移动一下栈指针
- 由于先进后出，不会出现内存碎片

什么时候不应该将对象存储在栈上
- 对象很大
- 对象在编译时不能确定
- 对象是函数的返回值，但因为特殊原因，不应该使用对象的值返回

new会先分配内存，然后在结果指针上构造对象

> [!faq] 如何选择在栈上或者堆上来分配内存？
> 生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。

==noexcept==
告诉编译器函数不会抛出异常，从而有利于编译器对程序做更多的优化。异常是在运行时检测的。为了实现运行时检测，编译器需要创建额外的代码，这会妨碍程序的优化。如果在运行是，`noexcept`函数向外抛出了异常。程序会直接终止，调用`std::terminate()`函数，该函数内部会调用`std::abort()`终止程序

适合用noexcept的情形：移动构造函数，移动分配函数，析构函数

>[!idea] operator=, 避免 if (&rhs != this) 的判断
>smart_ptr&
>operator=(smart_ptr rhs) noexcept
>{
>	rhs.swap(\*this);
>	return \*this;
>}

返回值优化(NRVO)：把对象直接构造在调用者的栈上
如果没有返回值优化，编译器将试图把本地的对象移动出去，如果程序中有分支的话，一般就不会进行返回值优化了，std::move 也会妨碍返回值的优化。


对于左值右值参数的推导规则
- 对于 template <typename T> foo(T&&), 如果传进去的参数是左值，T 的推导结果是左值引用；如果传进去的参数是右值，T 的推导结果是参数的类型本身。
- 如果 T 是左值引用，那 T&& 的结果仍然是左值引用，即 type& && 坍缩成了 type&
- 如果 T 是一个实际类型，那 T&& 的结果就是一个右值引用

T 是模板参数时，T&&  的作用主要是保持值类别进行转发，既可以是左值引用也可以是右值引用。

如何保持参数的值类别，即左值仍然是左值，右值仍然是右值？
使用 std::forward

```C++
template <typename T>
void bar(T&& s)
{
	foo(std::forward<T>(s));
}



