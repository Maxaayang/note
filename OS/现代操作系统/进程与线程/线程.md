每个进程有一个地址空间和一个控制线程。

#### 为什么需要多线程
1. 在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。
2. 线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。
3. 若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。

#### 经典的线程模型
**进程用于把资源集中到一起，而线程则是在 CPU 时被调度执行的实体。**

与进程相似，CPU 在线程之间的快速切换，制造了线程并行运行的假象。
线程之间是没有保护的，所有的线程都有完全一样的地址空间，即它们也共享同样的全局变量，线程还共享同一个打开文件集、子进程、定时器以及相关的信号等。

**每个进程中的内容：** 地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息
**每个线程中的内容：** 程序计数器、寄存器、堆栈、状态
程序计数器：记录接着要执行哪一条指令。
寄存器：保存线程当前的工作变量。
堆栈：记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。

线程的状态：运行、阻塞、就绪、终止
[[进程#^794cc4|进程的三种状态]]

在多线程的情况下，进程通常会从当前的单个线程开始，这个线程有能力通过调用一个库函数创建新的线程，创建新线程通常返回一个线程标识符，该标识符就是线程的名字，当一个线程完成工作后，可以调用一个库过程退出。
不同于进程，线程库无法利用时钟中断强制线程让出 CPU。

#### 在用户空间实现线程
实现线程包的两种方法：在用户空间、在内核中
线程的一个主要目标：允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他线程。

在用户空间管理线程时，每个进程需要有其专用的**线程表**，用来跟踪进程中的线程，该表由**运行时系统**管理。这些表和内核中的进程表类似，但仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态等。

把整个线程包放在用户空间中，内核对线程一无所知。
**优点：** 
* 用户级线程可以在不支持线程的操作系统上实现。
* 允许每个进程有自己定制的调度算法。
* 具有较好的可扩展性，因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果线程的数量非常大，就会出现问题。
* 线程如果可以在本地进行操作，就不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，从而使得线程调度非常快捷。

**问题：** 
* 如何实现阻塞系统调用。当一个线程阻塞进行系统调用时，会停止其他所有的线程，因为多线程也是通过 CPU 的快速切换来实现的。
* 如何处理缺页中断问题。
* 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU。

#### 在内核中实现线程
每个进程中没有了线程表，但是在内核中有用来记录系统中所有线程的线程表。
内核中的线程表和用户空间中的线程一样的每个线程的寄存器、状态和其他信息等，这些信息是传统内核所维护的每个单线程进程信息的子集，内核还维护了传统的进程表，以便跟踪进程的状态。

与用户空间中的线程不同，所有能够阻塞线程的调用都以系统调用的形式实现，当一个线程阻塞时，内核可以根据其选择，可以运行同一个进程中的另一个线程，或者另一个进程中的线程，但是在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU。

当某个线程被撤销时，就把它标志为不可运行的，但是其内核数据结构没有受到影响，在必须创建一个新线程时，就重新启动某个就线程。

内核线程不需要任何新的、非阻塞系统调用。

#### 混合实现
使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。

#### 调度程序激活机制
目标：模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更强大的灵活性。
如果线程阻塞在某个系统调用或页面故障上，只要在同一个进程中有任何就绪的线程，就应该有可能运行其他的线程。

内核给每个进程安排一定数量的虚拟处理器，让（用户空间）运行时系统将线程分配到处理器上，初始数量是一个，但是该进程可以申请更多的处理器并且在不用时退回，内核也可以取回分配出去的虚拟处理器，以便将它们分给需要更多处理器的进程。


#### 弹出式线程
一个消息到达导致系统创建一个处理该消息的线程，称为弹出式线程。
**好处：** 这种线程相当新，没有历史——没有必须存储的寄存器、堆栈等，每个线程从全新开始，每一个线程之间都完全一样，就有可能快速创建这类线程，从而导致消息到达与处理开始之间的时间非常短。

如果系统支持在内核上下文中运行线程，线程就有可能在那里运行，在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和 I/O 设备，在中断处理中可能有用，但是出错的内核线程会比出错的用户线程造成更大的损害。


















