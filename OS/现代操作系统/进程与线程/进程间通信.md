* 一个进程如何把信息传递给另一个进程。
* 确保两个或更多的进程在关键活动中不会出现交叉。
* 如何保证进程正确的执行顺序。

竞争条件：两个进程都读入同一个可写入的地址空间，然后后一个进行写入的进程将前一个进程写入的东西进行了覆盖。

临界区：对共享内存进行访问的程序片段。

避免竞争的方案需要满足的条件：
1. 任何两个进程不能同时处于其临界区。
2. 不应对 CPU 的速度和数量做任何假设。
3. 临界区外运行的进程不得阻塞其他进程。
4. 不得使进程无限期等待进入临界区。

![image.png](https://s2.loli.net/2021/12/26/bjAywvV8J9YPXhW.png)

#### 忙等待的互斥
1. 屏蔽中断
在单处理器中，可以使每个进程在刚刚进入临界区后立即屏蔽所有中断，在离开之前再打开中断，屏蔽中断之后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后 CPU 将不会被切换到其他进程。
**缺点**
* 如果一个进程屏蔽中断之后不再打开，整个系统可能会因此终止。
* 如果系统是多处理器的，则屏蔽中断仅仅对执行 disable 指令的那个 CPU 有效，其他 CPU 仍将继续运行并可以访问共享内存。
* 对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。当就绪进程队列之类的数据状态不一致时发生中断，则将导致竞争条件。

2. 锁变量
有一个共享（锁）变量，初始值为 0，当一个进程想要进入其临界区时，先测试这把锁，如果值为 0，则将其设置为 1 并进去临界区，如果锁的值为 1，则该进程将等待直到其值变为 0。
**问题**
假设一个进程读出锁变量的值并发现它为 0，恰好在它将其值设置为 1 之前，另一个进程被调度运行，将该锁变量设置为 1，当第一个进程再次运行时，它同样也将该锁设置为 1，则此时同时有两个进程进入临界区中。

3. 严格轮换法
忙等待：连续测试一个变量直到某个值出现为止。
自旋锁：用于忙等待的锁
```C
while(TRUE){
	while(turn != 0);
	critical_region();
	turn = 1;
	noncritical_region();
}

while(TRUE){
	while(turn != 1);
	critical_region();
	turn = 0;
	noncritical_region();	
}
```
	
可能会出现`turn = 1`，但是进程 1 在忙于执行非临界区的操作，从而进程 0 只能一直等待，直到进程 1 将`turn`设置为 0，这样就违反了条件 3。

4. Peterson 解法
```C
#define FALSE 0
#define TRUE  1
#define N     2          //进程数量

int turn;                //现在轮到谁？
int interested[N];       //所有值初始化为0（FALSE）

void enter_region(int process)    //进程是 0 或 1
{
	int other;                    //另一个进程号

	other = 1 - process;          //另一个进程
	interested[process] = TRUE;   //表示感兴趣
	turn = process;               //设置标志
	while(turn == process && interested[other] == TRUE);   //空语句
}

void leave_region(int process)    //进程：谁离开？
{
	interested[process] = FALSE;  //表示离开临界区
}
```

在两个进程几乎同时调用`enter_region`的情况，它们都将自己的进程号存入`turn`，但是只有后被保存进去的进程号才有效，前一个因被重写而丢失，假设进程 1 是后存入的，则`turn`为 1，当两个进程运行到`while`语句时，进程 0 将循环 0 次并进入临界区，而进程 1 则将不停地循环且不能进入临界区，直到进程 0 退出临界区为止。

5. TSL 指令
```C
//将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。
//读字和写字操作是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字，
//执行 TSL 指令的CPU 将锁住内存总线，以禁止其他 CPU 在
//本指令结束之前访问内存。

TSL RX,LOCK
```

用 TSL 指令进入和离开临界区
```C
enter_region:
	TSL REGISTER,LOCK      //复制锁到寄存器并将锁设为1
	CMP REGISTER,#0        //锁是0吗
	JNE enter_region       //若不是0，说明锁已被设置，所以循环
	RET                    //返回调用者，进入了临界区

leave_region:
	MOVE LOCK,#0           //在锁中存入0
	RET                    //返回调用者
```

用 XCHG 指令进入和离开临界区
```C
enter_region:
	MOVE REGISTER,#1           //在寄存器中放一个1
	XCHG REGISTER,LOCK         //交换寄存器与锁变量的内容
	CMP REGISTER,#0            //锁是0吗
	JNE enter_region           //若不是0，说明锁已被设置，因此循环
	RET                        //返回调用者，进入临界区

leave_region:
	MOVE LOCK,#0               //在锁中存入0
	RET                        //返回调用者
```

#### 信号量
信号量用来解决临界区问题以及实现进程在多处理器环境下的进程同步（协调共享资源访问）。

原子操作：一组相关联的操作要么不间断地执行，要么都不执行。

* 信号量由一个整形变量 S 和两个原子操作 PV 组成。
* P(Prolaag，荷兰语尝试减少)：信号量值减 1，如果信号量值小于 0，则说明资源不够用的，把进程加入等待队列。
* V (Verhoog，荷兰语增加)：信号量值加 1，如果信号量值小于等于 0，则说明等待队列里有进程，那么唤醒一个等待进程。

**使用场景**
1. 互斥访问，信号量的初值必须为一，PV 必须配对使用
2. 条件访问，初始信号量必须为 0，这样所有的线程调用 P 操作时都无法获取到锁，只能进行等待队列（相当于管程中的等待队列），当其余线程 B 调用 V 操作时会唤醒等待线程。
3. 阻塞队列，任何时刻只能有一个生产者线程或消费都线程访问缓冲区。并且当缓冲区满时，生产者线程必须等待，反之消费者线程必须等待。
* 任何时刻只能有一个线程操作缓存区：互斥访问，使用二进制信号量 mutex，其信号初始值为 1。
* 缓存区空时，消费者必须等待生产者：条件同步，使用资源信号量 notEmpty，其信号初始值为 0。
* 缓存区满时，生产者必须等待消费者：条件同步，使用资源信号量 notFull，其信号初始值为 n。

#### 互斥量
仅仅适用于管理共享资源或一小段代码。
互斥量只有两个状态：加锁和解锁
互斥量加锁和解锁的进程必须是同一个进程。

在（用户）线程中，因为没有时钟停止运行时间过长的线程，从而导致通过忙等待的方式来试图获得锁的线程将永远循环下去，不会得到锁，因为运行的线程不会释放锁让其他的线程运行。
在互斥锁中，取锁失败时，调用`thread_yield`将 CPU 放弃给另一个线程，从而没有忙等待，在该线程下一次运行时，再一次对锁进行测试。


#### 管程
管程相当于把对资源的操作封装了起来，当进程要对资源进行操作时，只要调用管程中的方法就可以了，而不用进程自己担心同步和互斥的问题，管程内部有自己的一套机制同步与互斥。

* 任一时刻只有一个线程执行管程代码。
* 正在管程内的线程可以放弃对管程的控制权，等待某些条件发生再继续执行。（自旋锁和信号量进入临界区域除非代码执行完，否则不会出现线程切换）。

条件变量：wait、signal
wait：导致调用进程自身阻塞，并且还将另一个以前等在管程之外的进程调入管程。
signal：通过对一个正在等待的进程执行signal将其唤醒，而执行signal的进程立即退出管程。

**信号量 VS 管程**
* 信号量本质是可共享的资源的数量； 而管程是一种抽象数据结构用来限制同一时刻只有一个线程进入临界区。
* 信号量是可以并发的，并发量取决于S初始值；而管程内部同一时刻最多只能有一个线程执行。
* 信号量与管理的资源紧耦合（即信号量S的初始值等同于资源的数目，且通过P V操作修改剩余可用的资源数量）；而在管程中需自行判断是否还有可共享的资源。
* 信号量的P操作可能阻塞，也可能不阻塞；而管程的wait操作一定会阻塞。
* 信号量的V操作如果唤醒了其他线程，当前线程与被唤醒线程并发执行；对于管程的signal操作，要么当前线程继续执行，要么被唤醒线程继续执行，二者不能并发。

#### 消息传递
为防止消息丢失，接收方一旦接收到信息，立马回送一条特殊的确认消息，如果发送方在一段时间间隔内未收到确认，则重发消息。
在每条原始消息中嵌入一个连续的序号来区分新的消息和一条重发的老消息。

**如何对消息进行编址**
1. 为每个进程分配一个唯一的地址，让消息按进程的地址编址。
2. 引入新的数据结构**信箱**，用来对一定的消息进行缓冲。
生产者向消费者信箱发送包含实际数据的消息。
消费者向生产者信箱发送空的消息。
目标信箱容纳那些已被发送但尚未被目标进程接收的消息。







