https://www.nowcoder.com/discuss/823405?source_id=profile_create_nctrack&channel=-1

https://www.nowcoder.com/discuss/610316?source_id=profile_create_nctrack&channel=-1

进程：一个正在执行程序的实例。
在对进程编程时不能对时序做任何想当然的假设，因为 CPU 在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的，而且当同一进程再次运行时，其运算速度通常是不可再现的。 

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。
如果一个程序运行了两遍，则算作两个进程。

#### 进程的创建
导致进程创建的 4 种主要事件
* 系统初始化
* 正在运行的程序执行了创建进程的系统调用
* 用户请求创建一个新进程
* 一个批处理作业的初始化

前台进程：同用户交互并且替他们完成工作的那些进程。
后台进程：与特定的用户没有关系，却具有某些专门的功能，例如接收电子邮件。
守护进程：停留在后天处理诸如电子邮件、Web页面、新闻、打印之类活动的进程。

利用[[进程控制#^548de9|fork]]函数创建新进程，通常子进程接着执行[[进程控制#^0ad6a0|execve]]或一个类似的系统调用，以修改其内存映像并运行一个新的程序。
在调用`fork`之后，父子进程具有相同的内存映像、同样的环境字符串和同样的打开文件，但具有不同的地址空间。在 UNIX 中，子进程的初始地址空间是父进程的一个副本，但是涉及两个不同的地址空间，**不可写的内存区是共享的**，或者，子进程通过**写时复制**共享父进程的所有内存。
通过两步建立进程，是为了在[[进程控制#^548de9|fork]]之后但在[[进程控制#^0ad6a0|execve]]之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的*重定向*。

**重定位**：为了避免两次从磁盘读入内存必须放在同一位置的限制，把进程重定位到内存的不同位置。

#### 进程的终止
进程终止的原因：
1. 正常退出（自愿的）
当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已完成，在 UNIX 中该调用是`exit`，而在 Windows 中，相关的调用是`ExitProcess`，面向屏幕的程序也支持自愿终止。

2. 出错退出（自愿的）
在给出了错误参数时，面向屏幕的交互式进程通常并不退出，相反会弹出一个对话框，并要求用户再试一次。

3. 严重错误（非自愿）
通常是由于程序中的错误所致。有些系统（如 UNIX），进程可以通知操作系统，希望自行处理某些类型的错误，在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。

4. 被其他进程杀死（非自愿）
某个进程执行一个系统调用通知操作系统杀死其他进程。在 UNIX 中，这个系统调用是`kill`，在 Win32 中对应的函数是`TerminateProcess`。在这两种情形中，“杀手”都必须获得确定的授权以便进行动作。

#### 进程的层次结构
在 UNIX 中，进程和它的所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。

在 Windows 中，所有的进程的地位是相同的，在创建进程的时候，父进程会得到一个特别的令牌（句柄），该句柄可以用来控制子进程，但是它有权把这个令牌送给某个其他进程。在 UNIX 中，进程就不能剥夺其子继承的“继承权”。

#### 进程的状态
尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。

进程停止的原因：
* 一个进程在逻辑上不能继续运行时，就会被阻塞。
* 因为操作系统调度另一个进程占用了 CPU，从而一个概念上能够运行的进程被迫终止。

进程的状态：
[[进程控制#^cbfe0c|进程的三种状态]] ^794cc4
1. 运行态（该时刻进程实际占用 CPU）
2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
3. 阻塞态（除非某种外部事件发生，否则进程不能运行）

![未命名.png](https://s2.loli.net/2021/12/25/xJ3DuZTLXjWk9O5.png)

* 在某些系统中，进程可以执行一个诸如`pause`的系统调用来进入阻塞状态。
* 在其他系统中，包括 UNIX，当一个进程从管道或设备文件（例如终端）读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。

#### 进程的实现
操作系统维护着进程表，每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件状态、账号的调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断一样。

与每一 I/O 类关联的是一个称作**中断向量**的位置，它包含中断服务程序的入口地址。

中断发生后操作系统最底层的工作步骤
1. 硬件压入堆栈程序计数器等。
2. 硬件从中断向量装入新的程序计数器。
3. 汇编语言过程保存寄存器值。
4. 汇编语言过程设置新的堆栈。
5. C 中断服务例程运行（典型地读和缓冲输入）。
6. 调度程序决定下一个将运行的进程。
7. C 过程返回至汇编代码。
8. 汇编语言过程开始运行新的当前进程。










