每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一**页**或**页面**。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的页的部分装入物理内存并重新执行失败的命令。

#### 分页

==分段的缺点==：当应用程序过多时，或者内存碎片过多而无法容纳新进程，又或者重新加载某内存段(之前交交换出去的)时，找不到合适的内存区域
- 段的长度大小不一，无法确定用什么数据结构来表示一个段，以及难以确定一个段是已经分配了还是空闲着
- 段的长度大小不一，更容易产生碎片
- 段的长度大小不一，在内存与磁盘进行交换时，有的段需要时间长，有的段需要时间短，会导致系统抖动
- 段使得虚拟内存地址空间难以实施

==原因==：只分段的情况下，线性地址就是物理地址，两者是连续的，不够灵活，不可能每次都找到合适的内存区域

由程序产生的地址称为虚拟地址，虚拟地址构成了一个虚拟地址空间。
虚拟地址被送到**内存管理单元**（Memory Management Unit, MMU），MMU 把虚拟地址映射为物理内存地址。
![image.png](https://s2.loli.net/2021/12/27/SwfUTj1bh43CYkI.png)

虚拟地址被按照固定的大小划分成页面，在物理内存中对应的单元称为页框，页面和页框的大小通常是一样的。
RAM 和磁盘之间的交换总是以整个页面为单元进行的。
![image.png](https://s2.loli.net/2021/12/27/E8FHcMfjhUeDLRg.png)

如果页面没有被映射，就会使 CPU 陷入到操作系统，称为**缺页中断**或**缺页错误**。操作系统找到一个很少使用的页框且把它的内容写入磁盘，随后把需要访问的页面读到刚才回收的页框中，修改映射关系，如何重启引起陷阱的指令。
[[地址翻译#^67e6b8|当页面发生命中时]]
[[地址翻译#^294e7c|处理缺页]]

![image.png](https://s2.loli.net/2021/12/27/VembnOQx7aC2crM.png)

16 位虚拟地址被分为 4 位的页号和 12 位的偏移量
用页号作为页表的索引，从而得出对应于该虚拟页面的页框号。
如果“在/不在”位是 1，则将在页表中查到页框号复制到输出寄存器的高 3 位中，再加上输入虚拟地址中的低 12 位偏移量，就构成了 15 位的物理地址，输出寄存器的内容随即被作为物理地址送到内存总线。

#### 页表
虚拟页号可以用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号，然后把页框号拼接到偏移量的高位端，替换掉虚拟页号，形成送往内存的物理地址。
![image.png](https://s2.loli.net/2021/12/27/5L17NmiGnxFJSHt.png)

**保护位：** 指出一个页允许什么类型的访问。
**修改位：** 在写入一页时由硬件自动设置。
**访问位：** 在页面被访问时系统自动设置，用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。
**高速缓存禁止位：** 对于映射到设备寄存器而不是常规内存的页面很重要，具有独立的 I/O 空间而不使用内存映射 I/O 的机器不需要这一位。

#### 加速分页过程
分页系统的两个主要问题：
* 虚拟地址到物理地址的映射必须非常快，因为每次访问内存都需要进行虚拟地址到物理地址的映射。
* 如果虚拟地址空间很大，页表也会很大，并且每个进程都需要自己的页表。

如何设计大而快速的页表映射？
1. 使用由“快速硬件寄存器”阵列组成的单一页表，每一个页表项对应一个虚拟页面，虚拟页号作为索引。当启动一个进程时，操作系统把保存在内存中的进程页表的副本载入到寄存器中，在进程运行过程中，不必再为页表而访问内存。
**优点**：简单并且在映射过程中不需要访问内存。
**缺点**：在页表很大时，代价高昂，每一次上下文切换都必须装载整个页面，从而导致性能降低。

2. 将整个页表都放在内存中，硬件仅仅是一个指向页表起始位置的寄存器，从而在上下文切换时，进行“虚拟地址到物理地址”的映射只需要重新装入一个寄存器。
**缺点**：执行每条指令都需要一次或多次内存访问来完成页表项的读入，速度非常慢。

**转换检测缓冲区**
[[地址翻译#利用 TLB 加速地址翻译|利用 TLB 加速地址翻译]]
大多数的程序总是对少量的页面进行多次访问。
转换检测缓冲区 / 相联存储器 / 快表：为计算机设置的一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不需要再访问页表。

![image.png](https://s2.loli.net/2021/12/27/BROJSNH9DcI7xvr.png)

软失效：一个页面访问在内存中而不在 TLB 中。
硬失效：页面本身不在 TLB 中也不在内存中。
页表遍历：在页表结构中查找相应的映射。

**缺页错误** ^d41e52
1. 次要缺页错误：所需的页面可能在内存中，但却未记录在该进程的页表里。
2. 严重缺页错误：需要从硬盘重新调入页面。
3. 程序可能访问了一个非法地址，根本不需要向 TLB 中新增映射，操作系统一般通过报告段错误来终止该程序。

#### 针对大内存的页表
1. [[地址翻译#多级页表|多级页表]]

![image.png](https://s2.loli.net/2021/12/27/rUp7xVtuSnTwE8z.png)

每个页面的大小为 4KB，共有 2^20 个页面
顶级页表有 1024 个表项，对应于 10 位的 PT1 域。
虚拟地址空间按照 4KB 的大小分块，所以顶级页表中的 1024 个表项的每一个都表示 4M 的块地址范围。

2. 倒排页表
每个页框对应一个表项，而不是每个虚拟页面对应一个表项。
优点：节省了大量的空间。
缺点：很难进行从虚拟地址到物理地址的转换。
在倒排页表中则是以物理页框号作为页表项索引，映射到 (进程号，虚拟页号 VPN)。

当进程尝试访问一个虚拟内存地址之时，CPU 在通过地址总线把 VPN 发送到 MMU 之后，基于倒排页表的设计，MMU 并不知道这个 VPN 对应的是不是一个缺页，所以不得不扫描整个倒排页表来找到该 VPN，而最要命的是就算是一个非缺页的 VPN，每次内存访问还是需要执行这个全表扫描操作。

可以用 TLB 来解决。
当发生 TLB 失效时，需要软件搜索整个倒排页表。
可以建立一张散列表来实现搜索，用虚拟地址来散列，当所有在内存中的具有相同散列值的虚拟页面被链接在一起，如果散列表中的槽数与机器中物理页面数一样多，那么散列表的平均长度将会是 1 个表项的长度，将会大大提高映射速度，一旦页框号被找到，新的（虚拟页号，物理页框号）对就会被装载到 TLB 中。


![image.png](https://s2.loli.net/2021/12/27/iTtMfXmOx4CkrWn.png)

https://www.cnblogs.com/cangqinglang/p/14754718.html


