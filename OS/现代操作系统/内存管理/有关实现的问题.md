#### 与分页有关的工作
1. 创建一个新进程时
* 确定程序和数据在初始时有多大，并为它们创建一个页表。
* 在内存中为页表分配空间并对其进行初始化。
* 当进程被换出时，页表不需要驻留在内存中，但当进程运行时，页表必须在内存中。
* 要在磁盘交换去中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。
* 用程序正文和数据交换区进行初始化，从而当新进程发生缺页中断时，可以调入需要的页面。
* 把有关页表和磁盘交换区的信息存储在进程表中。

2. 调度一个进程执行时
* 必须为新进程重置 MMU，刷新 TLB，从而清除以前的进程遗留的痕迹。
* 新进程的页表必须称为当前页表，通常可以通过复制该页表或者把一个指向它的指针放进某个硬件寄存器来完成。
* 在进程初始化时可以把进程的部分或全部页面装入内存中以减少缺页中断的发生。

3. 缺页中断发生时
* 操作系统必须通过硬件寄存器确定是哪个虚拟地址造成了缺页中断，从而计算需要哪个页面，并在磁盘上对该页面进行定位。
* 必须找到合适的页框存放新页面，必要时还要置换老的页面，然后把所需的页面读入页框。
* 退回程序计数器，使程序计数器指向引起缺页中断的指令，并重新执行该指令。

4. 当进程退出时
* 必须释放进程的页表、页面和页面在硬盘上所占用的空间。
* 如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止的时候，才可以释放内存和磁盘上的页面。

#### 缺页中断处理
1. 硬件陷入内核，在堆中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的 CPU 寄存器中。
2. 启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。
3. 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。
4. 一旦知道了发生缺页中断的虚拟地址，操作系统检査这个地址是否有效，并检査存取与保护是否致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检査是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。
5. 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。
6. 一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统査找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另个用户进程运行。
7. 当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。
8. 恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。
9. 调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。
10. 该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。

#### 后备存储
**页面被换出时会存放在磁盘上的哪个位置？**
在磁盘上分配页面空间最简单的算法是在磁盘上设置特殊的交换分区，甚至从文件系统划分一块独立的磁盘。

* 当系统启动时，交换分区为空，并在内存中以单独的项给出它的起始和大小。
* 当第一个进程启动时，留出与这个进程一样大的交换区块。
* 当新进程启动后，同样被分配与其核心映像同等大小的交换分区。
* 进程结束后，释放其在磁盘上的交换区。

交换分区以空闲块列表的形式组织。
与每个进程对应的是其交换区的磁盘地址，即进程映像所保存的地方。

计算写回地址：将虚拟地址空间中页面的偏移量加到交换区的开始地址。
在进程启动前必须初始化交换区：
* 将整个进程映像复制到交换区，以便随时可将所需内容装入。
* 将整个进程装入内存，并在需要时换出。

如何解决进程在启动后可能增大的问题？
原因：程序正文通常是固定的，但数据有时会增长，堆栈也总是在随时增长。
措施：为正文、数据、堆栈分别保留交换区，并且允许这些交换区在磁盘上多于一个块。

事先什么都不分配：在页面换出时为其分配磁盘空间，并在换入时回收磁盘空间，从而内存中的进程不必固定于任何交换空间。
**缺点**：内存中每个页面都要记录相应的磁盘空间。

![y6eFjcAHVhSZL5s](https://s2.loli.net/2021/12/30/y6eFjcAHVhSZL5s.png)











