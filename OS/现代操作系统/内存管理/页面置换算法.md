#### 最优页面置换算法
每个页面用该页面首次被访问所要执行的指令数作为标记，置换标记最大的页面。
这种方法是**无法实现**的，因为当缺页中断发生时，操作系统无法知道各个页面下一次什么时候被访问。

#### 最近未使用页面置换算法
系统为每个页面设置了两个状态位，当页面被访问（读或写）时设置 R 位，当页面被写入（即修改）时设置 M 位。
当启动一个进程时，它的所有页面的两个位都由操作系统设置成 0，R 位被定期地清零，以区别最近没有被访问的页面和被访问的页面。

NRU（Not Recently Used，最近未使用）算法随机地从类编号最小的非空类中挑选一个页面淘汰。

**优点**：易于理解和能够有效地被实现。

#### 先进先出页面置换算法
由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头，当发生缺页中断时，淘汰表头的页面，并将新调入的页面加到表尾。

**缺点**：可能会淘汰最早进入但最常用的页面，所以很少纯粹使用 FIFO 算法。

#### 第二次机会页面置换算法
为了避免 FIFO 算法中将最常使用的页面置换出去，可以检查老页面的 R 位，如果是 0，就立即置换掉，如果是 1，就将 R 位清零，并把该页面放到链表的尾端，修改它的装入时间使它像刚装入的一样，然后继续搜索。

如果所有的 R 位都被设置了，操作系统就会一个接一个将每个页面移动到链表的尾部，并清除被移动页面的 R 位，最后算法将又回到第一个页面，此时它的 R 位已被清除了，所以将会被淘汰，所以这个算法总是可以结束的。

![image.png](https://s2.loli.net/2021/12/28/k6LTFlvbJexZOnr.png)

#### 时钟页面置换算法
在二次机会算法中，要经常在链表中移动页面，既降低了效率又不是很必要。

改进：将所有页面保存在一个环形链表中，一个指针指向最古老的页面。
当缺页中断发生时，先检查指针指向的页面，如果 R 位是 0，就淘汰这个页面并将新页面插入这个位置，然后将指针后移一位。如果 R 位是 1， 就将其清除，并将指针前移一个位置，直到找到一个 R 位为 0 的页面为止。

![image.png](https://s2.loli.net/2021/12/28/VyeukjG7gat8PEo.png)

#### 最近最少使用页面置换算法
LRU（Least Recently Used，最近最少使用）页面置换算法：在缺页中断发生时，置换未使用时间最长的页面，因为已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会使用。

**缺点**：需要在内存中维护一个所有页面的链表，最多最近使用的页面在表头，最近最少使用的页面在表尾，但是每次访问内存时都需要更新整个链表，在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。

#### 工作集页面置换算法
请求调页：页面在需要时调入而不是预先装入。
预先调页：在进程运行前预先装入其工作集页面。
局部性访问：在进程运行的任何阶段，都只访问较少的一部分页面。
工作集：一个进程当前正在使用的页面的集合。
颠簸：每执行几条指令程序就发生中断。
工作集模型：设法跟踪进程的工作集，以确保在让进程运行以前，工作集就已在内存中了。
工作集模型的目的：大大减少缺页中断率。
当前实际运行时间：一个进程从它开始执行到当前所实际使用的 CPU 时间总数。
每个表项至少包含两条信息：上次使用该页面的近似时间、R（访问）位

在处理每个表项之前，先检查 R 位，如果是 1，就把当前时间写进页表项的“上次使用时间”域，表示缺页中断发生时该页面正在被使用。
* 如果 R 是 0，就计算它的生存时间，然后与 t 做比较，如果生存时间大于 t，就用新的页面置换它，扫描会继续进行更新剩余的表项。
* 如果 R 是 0 同时生存时间小于或等于 t，把该页面临时保留下来，但是要记录生存时间最长的页面，如果扫描完整个页表却没有合适的淘汰页面，就把生存时间最长的页面淘汰。
* 如果所有页面 R 均为 1，就随机选择一个页面淘汰。

#### 工作集时钟页面置换法
![image.png](https://s2.loli.net/2021/12/28/djWU71ucatDZ2rJ.png)


#### 总结
![image.png](https://s2.loli.net/2021/12/28/WBHw3iMZSxD6lK2.png)











