# CPU工作模式

## 实模式

- 运行真实的指令，对指令的动作不做区分，直接执行指令的真实功能
- 发往内存的地址是真实的，对任何地址不加限制地发往内存

内存地址：段寄存器左移4位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存

中断
- 硬件中断：中断控制器给CPU发送一个电子信号，CPU会对这个电子信号做出应答，随后中断控制器会将中断信号发送给CPU
- INT指令：这个指令后会跟一个常数，即软中断号

内存中需要放一个中断向量表来实现中断，这个表的地址和长度由CPU的特定寄存器IDTR指向，在实模式下，每个条目由代码段地址和段内偏移组成。

![[Pasted image 20220826095240.png]]

## 保护模式

相比实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是32位的。

CPU特权级分为四级，R0-R3

![[Pasted image 20220826100029.png]]

全局段描述表：多个段描述符在内存中形成，其基地址和长度由CPU和GDTR寄存器指示

段寄存器不再存放段基地址，而是具体的段描述符，访问一个内存地址时，段寄存器中的索引首先会结合GDTR寄存器找到内存中的段描述符，再根据其中的段信息判断能不能访问成功。

段寄存器是由影子寄存器、段描述符索引、描述符表索引、权限级别组成
![[Pasted image 20220826101506.png]]
影子寄存器是硬件为了减少性能损耗而设计的一个段描述符的高速缓存

通常CS和SS中的RPL组成了CPL
CPL表示发起访问者要以什么权限去访问目标段，当CPL大于目标段DPL时，则CPU禁止访问，只有CPL小于等于目标段的DPL时才能访问

保护模式下因为中断需要进行权限检查，所以每个中断都使用中断门来表示，中断向量表中的条目也变成了中断门

- CPU检查中断号是否大于最后一个中断门描述符，然后检查描述符类型、是否为系统描述符、是不是存在于内存中
- 检查中断门描述符中的段选择子指向的段描述符
- 权限检查，如果 CPL 小于等于中断门的 DPL，并且 CPL 大于等于中断门中的段选择子所指向的段描述符的 DPL，就指向段描述符的 DPL。进一步的，CPL 等于中断门中的段选择子指向段描述符的 DPL，则为同级权限不进行栈切换，否则进行栈切换。如果进行栈切换，还需要从 TSS 中加载具体权限的 SS、ESP，当然也要对 SS 中段选择子指向的段描述符进行检查。

## 长模式

相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽为64位

在长模式下，CPU不再对段基址和段长度进行检查，只对DPL进行相关的检查


# 地址转换

为什么会有虚拟地址
- 如何保证程序之间没有内存地址的冲突
- 如何保证程序之间不会互相读写各自的内存空间
- 如何解决内存容量的问题
- 如何解决扩展后的情况(即不同的程序在不同的计算机上)

==链接器的作用==
把多个代码模块组装在一起，并解决模块之间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图

==为什么要进行分页？==

为了增加灵活性和节约内存空间，页表不存放虚拟地址和物理地址的对应关系，只存放物理页面的地址，MMU以虚拟地址为索引去查表返回物理页面地址。

![[Pasted image 20220826105123.png]]

==MMU的工作流程==
第一个位段索引顶级目录中的一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存。