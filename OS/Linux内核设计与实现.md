# 进程调度

- 抢占式任务：有调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会
- 非抢占式任务：除非进程自己主动停止，否则它会一直执行

抢占：强制挂起
让步：主动挂起自己

非抢占式任务的缺点：
- 调度程序无法对每个进程该执行多长时间做出统一的规定，所以进程独占的处理器时间可能超出用户的预料
- 绝不做出让步的进程可能使系统崩溃

时间片：分配给每个可运行进程的处理器时间段
有效管理时间片可以是调度程序从系统全局的角度做出决定，还可以避免个别进程独占系统资源

## 策略

进程可以分为**I/O消耗型**和**处理器消耗型**
对于处理器消耗型的进程，调度策略往往是尽量降低它们的调度频率，而延长其运行时间

Linux的优先级范围
- 用nice值
	范围是从-20 ~ +19， 默认为0
	nice值越大，优先级越低
	nice值较小的进程可以获得更多的处理器时间

- 实时优先级
	范围是 0 ~ 99
	数值越高，进程的优先级越高
	任何实时进程的优先级都高于普通的进程

- 时间片过长鬼导致系统对交互的响应欠佳，使人觉得无法并发执行应用程序
- 时间片太短会明显增加进程切换带来的处理器耗时，因为会有一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短
- I/O消耗型的进程不需要长的时间片
- 处理器消耗型的进程希望越长越好

完全公平调度算法(CFS)的调度器并没有直接分配时间片到进程，而是将处理器的使用比例划分给了进程，这样就导致进程所获得的处理器时间其实是和系统密切相关的，并且这个比例还会被nice影响

在Linux的CFS调度器中，抢占时机取决于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程，否则推迟其运行。

==如何给一个进程分配给定的优先级和时间片？==
分配一个给定的处理器使用比，即如果本来应该分配给某个进程的处理器使用比例被其他进程占用了，那么当这个进程需要使用处理器的时候，CFS会立即抢占另一个进程让其运行。

## Linux调度算法

将优先级以nice值形式输出给用户空间会遇到的问题
- 将nice值映射到时间片，必然需要将nice单位值对应到处理器的绝对时间，但这样会导致进程切换无法最优化进行，是给定nice值到时间片映射与进程运行优先级混合的共同作用的结果
	同样是100ms，两个低优先级的进程可能需要没10ms进行两次的切换，而如果是两个普通的进程，可能每50ms才切换一次

- 相对nice值

-  如果执行nice值到时间片的映射，需要能分配一个绝对时间片，而且这个绝对时间片必须能够在内核的测试范围内，这就要求绝对时间片必须是定时器节拍的整数倍==定时器与测量==
	- 最小时间片必然是定时器节拍的整数倍
	- 系统定时器限制了两个时间片的差异：连续的nice值映射到时间片，其差别范围多至10ms或者少至1ms
	- 时间片还会随着定时器节拍改变

- 基于优先级的调度器为了优化交互任务而唤醒相关进程的问题
	- 为了进程能够更快地投入运行，对新要唤醒的进程提升优先级，即使它们的时间片已经用完了
	- 这样也给了某些特殊的睡眠/唤醒用例玩弄调度器后门的机会，使得给定的进程打破公平原则，获得更多的处理器时间，损害系统中其他进程的利益。

可以通过将nice值呈几何增加而非算数增加解决第二个问题
采用一个新的度量机制将从nice值到时间片的映射与定时器节拍分离开来，解决第三个问题
但是没有解决实质问题：分配绝对的时间片引发的固定的切换频率，给公平性造成很大的变数

CFS通过给进程分配一个处理器使用比重来确保进程调度中能有恒定的公平性，而将切换频率至于不断变动中。

CFS允许每一个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不采用分配给每个进程时间片的做法，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重。每个进程都按照其权重在全部可运行进程中所占比例的时间片来运行

目标延迟：CFS为了计算准确的时间片而为完美多任务中的无限小调度周期的近似值设立的一个目标。

最小粒度：每个进程获得的时间片的底线

CFS：
- 任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的
- nice值对时间片的加权是几何加权
- nice对应的绝对时间不再是一个绝对值，而是处理器的使用比

## Linux调度的实现

### 时间记账

当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期，一个进程的时间片被减少到0时，就会被另一个尚未减到0的时间片可运行进程抢占

CFS不再有时间片的概念，但是必须维护每个进程运行的时间记账，因为他需要确保每个进程只在公平分配给它的处理器时间内运行

vruntime保存进程的虚拟运行时间，与定时器节拍不再相关，vruntime可以帮助我们逼近CFS模型所追求的理想多任务处理器，因为处理器无法实现完美的多任务，必须依次运行每个任务，所以CFS使用vruntime来记录一个程序到底运行了多长时间以及还应该运行多久。

### 进程选择

当CFS需要选择下一个运行进程时，会挑一个具有最小vruntime的进程

CFS使用**红黑树**来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程，它会把最左边的叶子结点缓存起来进行下次的调用

每个 CPU 都有自己的 struct rq 结构，其用于描述在此 CPU 上所运行的所有进程，其包括一个实时进程队列 rt_rq 和一个 CFS 运行队列 cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行。

如何均衡CPU之间的负载？
- Linux内核会在每个时钟周期末尾触发rebalance
- CPU发现自己队列为空就会去摘取其他CPU的任务

CFS从红黑树中删除进程是发生在进程堵塞(变为不可运行态)或者终止态(结束运行)

### 调度器的入口

Schedule通常都需要和一个具体的调度类想关联，即会找到一个最高优先级的调度类——后者需要有自己的可运行队列，然后问下一个该运行的进程

==优化==：如果知道所有的任务都在公平类中，那么就可以直接调用那个函数

### 睡眠和唤醒

为什么要有睡眠？
如果没有这种特殊的状态，调度程序就可能选出一个本不愿意执行的程序，并且休眠就必须以轮询的方式实现了

休眠时内核的操作
进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择一个和执行一个其他进程

唤醒：进程被置为可执行状态，然后再从等待队列中移到可执行红黑树中。

加入等待队列的步骤
- 调用宏DEFINE_WAIT()创建一个等待队列的项
- 调用add_wait_queue()把自己加入到队列中，该队列会在进程等待的条件满足时唤醒它，必须在其他地方撰写相关的代码，在事件发生时，对等待队列执行wake_up()操作
- 调用prepare_to_wait()方法将进程的状态变更为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。而且该函数如果有必要的话，会将进程加回到等待队列中
- 如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程，即伪唤醒(唤醒不是因为事件的发生)，因此检查并处理信号
- 当进程被唤醒的时候，会再次检查条件是否为真，如果是，就跳出循环，否则再次调用schedule()并一直重复这步操作
- 当条件满足之后，进程将自己设置为TASK_RUNING并调用finish_wait()把自己移出等待队列

wake_up()：唤醒指定的等待队列上的所以进程，调用try_to_wake_up()，将进程设置为TASK_RUNNING状态，，调用enqueue_task()将此进程放入红黑树，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置need_resched标志