![image.png](https://s2.loli.net/2021/12/20/YhWcmoRnvO8z3Cb.png)

页表基址寄存器(Page Base Register, PTBR)指向当前页表。
n 位的虚拟地址包括一个 p 位的虚拟页面偏移，一个(n-p)位的虚拟页号。

![image.png](https://s2.loli.net/2021/12/20/PTdgnlRaz9fWFpH.png)

**当页面发生命中时：** ^67e6b8
1. 处理器生成一个虚拟地址，并将它传送给 MMU。
2. MMU 生成 PTE 地址（页表项地址），并从高速缓存/主存请求得到它。
3. 高速缓存/主存向 MMU 返回 PTE。
4. MMU 构造物理地址，并把它传送给高速缓存/主存。
5. 高速缓存/主存返回所请求的数据字给处理器。

![image.png](https://s2.loli.net/2021/12/20/IJcoFXtQNdsgRlm.png)

[[虚拟内存#^d41e52|缺页错误]]
**处理缺页：** ^294e7c
1. 处理器生成一个虚拟地址，并将它传送给 MMU。
2. MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。
3. 高速缓存/主存向 MMU 返回 PTE。
4. PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。
5. 缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。
6. 缺页处理程序页面调入新的页面，并更新内存中的 PTE。
7. 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图中的步骤之后，主存就会将所请求字返回给处理器。

![image.png](https://s2.loli.net/2021/12/20/qhrDIQJ32nBMeUk.png)

#### 结合高速缓存和虚拟内存
在任何既使用虚拟内存又使用 SRAM 高速缓存的系统中，大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓存无需处理保护问题，因为访问权限的检査是地址翻译过程的一部分。

![image.png](https://s2.loli.net/2021/12/20/3HfimOvlqp6Xj1M.png)
VA：虚拟地址、PTEA：页表条目地址、PTE：页表条目、PA：物理地址


#### 利用 TLB 加速地址翻译
TLB 是 MMU 中包括了一个关于 PTE 的小的缓存。
![image.png](https://s2.loli.net/2021/12/20/VmQKNIrd3vUhiFW.png)

当 TLB 命中时的步骤：
1. CPU 产生一个虚拟地址。
2. MTU 从 TLB 中取出相应的 PTE。
4. MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。
5. 高速缓存/主存将所请求的数据字返回给 CPU。

当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。

![image.png](https://s2.loli.net/2021/12/20/4fHWkdLqVPtNjrK.png)


#### 多级页表
压缩页表的常用方法：层次结构的页表

一级页表负责映射虚拟地址空间中的一个 4MB 的片，每一个片都是由 1024 个连续的页面组成。
如果片 *i* 中的每个页面都未被分配，那么一级页面 PTEi 就为空。
如果在片 *i* 中至少有一个页是分配了的，那么一级 PTEi 就指向一个二级页表的基址。
二级页表中的每个 PTE 负责映射一个 4KB 的虚拟内存页面。

**两级页表**
![image.png](https://s2.loli.net/2021/12/20/PEUz2tYSviWIke3.png)

**k级页表**
![image.png](https://s2.loli.net/2021/12/20/9ZPGcld7b5D4mN1.png)
每个 VPNi 都是一个到第 i 级页表的索引。
第 j 级页表中的每个 PTE 都指向第 j+1 级的某个页表的基址。
第 k 级页表中的每个 PTE 包含某个物理页面的 PPN，或者一个磁盘块的地址。

多级页表的好处：
1. 如果一级页表中的一个 PTE 是空的，那么相应的二级页表就不会存在，对于一个典型的程序，4GB 的虚拟地址空间的大部分是未分配的，可以节约大量资源。
2. 只有一级页表才需要总是在主存中；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中。






















