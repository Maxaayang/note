内存映射：将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容的过程。

虚拟内存区域可以映射到两种类型的对象中的一种：
1. Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。
2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。在磁盘和内存之间没有实际的数据传送，所以映射到匿名文件的区域中的页面有时也被叫做请求二进制零的页。

一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。交换文件也叫做交换空间或交换区域。

#### 共享对象
许多进程拥有同样的只读代码区域，内存映射提供了一种清晰的机制，用来控制多个进程如何共享对象。

一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。

如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的，并且这些变化也会反映在磁盘上的原始对象中。

对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。

![image.png](https://s2.loli.net/2021/12/20/9keH8O2SslMjaGP.png)

即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。

对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。
只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障，故障处理程序会在物理内存中创建这个页面的一个副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。

![image.png](https://s2.loli.net/2021/12/20/47n2bru8UHgQfM6.png)


#### fork 函数
[[进程控制#创建和终止进程]]
当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的==写时复制==。 ^d312da

当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。


#### execve 函数
[[进程控制#加载并运行程序]]
```C++
execve("a.out", NULL, NULL);
```

`a.out`程序有效地替代了当前的程序，加载并运行`a.out`需要以下的步骤：
1. 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。
2. 映射私有区域。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 a.out 文件中的. text 和. data 区。bss 区域是请求二进制零的，映射到匿名文件，其大小包含在 a.out 中。栈和堆区域也是请求二进制零的，初始长度为零。图 9-31 概括了私有区域的不同映射。
3. 映射共享区域。如果 a.out 程序与共享对象（或目标）链接，比如标准 C 库 libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。
4. 设置程序计数器（PC）。execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。

![image.png](https://s2.loli.net/2021/12/20/WD9KtOXNk23m6Jb.png)

#### 使用 mmap 函数的用户级内存映射
参见 CSAPP 9.8.4








