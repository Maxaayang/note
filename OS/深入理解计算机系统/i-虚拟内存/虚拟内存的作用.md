### 虚拟内存作为内存管理的工具

![image.png](https://s2.loli.net/2021/12/19/3kTfBACP4g6xI9t.png)
操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。
多个虚拟页面可以映射到同一个共享物理页面上。

1. **简化链接。** 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据世纪存放在物理内存中的何处。
2. **简化加载。** 加载器为代码和数据段分配虚拟页，把它们标记为无效（未被缓存），将页表条目指向目标文件中适当的位置。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。
3. **简化共享。** 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码中的一个副本，而不是在每个进程中都包括单独的内核和 C 标准库的副本。
4. **简化内存分配。** 当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。页面可以随机地分散在物理内存中。

### 虚拟内存作为内存保护的工具
提供独立的地址空间使得区分不同进程的私有内存变得容易。

每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE，所以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面的访问。

![image.png](https://s2.loli.net/2021/12/19/Fobfulq63CPmiDk.png)

如果有一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为“段错误”。












