### 进程控制
#### 获取进程 ID
每一个进程都有一个唯一的正数（非零）进程 ID（PID）。
```C++
#include<sys/types.h>
#include<unistd.h>

pid_t getpid(void);		//返回调用进程的 PID
pid_t getppid(void);	//返回父进程的 PID

//在 Linux 系统中，返回的 PID 被定义为 int
```

#### 创建和终止进程
进程的三种状态 ^cbfe0c
* 运行：要么正在执行，要么等待执行
* 停止：进程的执行被挂起且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU 信号时，进程就停止，直到收到 SIGCONT 信号，进程再次开始运行。
* 终止：原因：收到一个信号，该信号的默认行为时终止进程；从主程序返回；调用 exit 函数。
exit 函数以 status 退出状态来终止进程（另一种设置退出状态的方法是从主程序返回一个整数值）。
```C++
#include <stdlib.h>

void exit(int status);
```

**父进程创建子进程**  
[[内存映射#fork 函数]]
```C++
#include <sys/types.h>
#include <unistd.h>

// 返回：子进程返回 0，父进程返回子进程的 PID，如果出错，返回 -1
pid_t fork(void);
```

^548de9

**新建的子进程几乎但不完全与父进程相同**
子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份==副本==，包括代码和数据段、堆、共享库以及用户栈。
子进程获得与父进程任何打开文件描述相同的==副本==，意味着当父进程调用`fork`时，子进程可以读写父进程中打开的任何文件。
==最大的区别==，子进程和父进程拥有不同的 PID。

`fork`函数只被调用一次，但是会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。
在父进程中，`fork`返回子进程的 PID，在子进程中，`fork`返回 0.因为子进程的 PID 总是非零，所以返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。

* 并发执行：父进程与子进程是并发运行的独立进程，内核能够以==任意方式==交替执行他们的逻辑控制流中的指令。
* 相同但是独立的地址空间：如果在`fork`返回之后立即暂停这两个进程，则会发现两个进程的地址空间是相同的，然而，因为两个进程时独立的进程，它们都有自己的私有地址空间。
* 共享文件。

![image.png](https://s2.loli.net/2021/12/18/GKskJ9yNlfQuiYb.png)

#### 回收子进程
当一个进程由于某种原因终止时，进程会保持在一种已终止的状态中，直到被他的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。
僵死进程：已终止了但是还未被回收的进程。
即使僵死进程没有运行，它们仍然消耗系统的内存资源。

init 进程的 PID 为 1，是在系统启动时由内核创建的，不会终止，是所有进程的祖先。
 如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。
 如果父进程没有回收它的僵死子进程就终止了，内核会安排 init 进程去回收它们。
 
 **程序不会按照特定的顺序回收子进程，如果想要顺序回收，可以将子进程的 PID 顺序存储在一个数组中，然后再回收。**
 
 #### 让进程休眠
 ```C++
 #include <unistd.h>
 
 //如果请求的时间到了，sleep 返回 0，否则返回还剩下的要休眠的秒数。
 //如果被一个信号中断而过早的返回？
 unsigned int sleep(unsigned int secs);
 
 //该函数让调用函数休眠，直到该进程收到一个信号
 int pause(void);
 ```
 
 #### 加载并运行程序
 [[内存映射#execve 函数]]
 ```C++
 #include <unistd.h>
 
 //在当前上下文中加载并运行一个新程序，只有当出现错误时，execve 才会返回调用程序，execve调用一次且从不返回。
 //如果成功，则不返回；如果错误，则返回 -1
 //filename，可执行目标文件
 //argv，参数列表
 //envp，环境变量列表
 int execve(const char *filename, const char *argv[], 
 			const char *envp[]);
 ```

^0ad6a0

`execve`函数在当前进程的上下文中加载并运行一个新的程序，它会==覆盖当前进程的地址空间，但是并没有创建一个新的进程，新的程序仍然有相同的 PID，并且继承了调用 `execve`函数时已打开的所有文件描述符。==

![image.png](https://s2.loli.net/2021/12/18/jFHRMzQYwrb7WBd.png)

`argv[0]`是可执行目标文件的名字












