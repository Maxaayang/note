低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的，信号提供了一种机制，通知用户进程发生了这些异常。

1) 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。
发送信号的原因：
* 内核检测到一个系统事件，比如除零错误或子进程终止。
* 一个进程调用了`kill`函数，显式地要求内核发送一个信号给目的进程。
一个进程可以发送信号给自己。

2) 接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。

在任何的时刻，一种类型至多只会有一个待处理的信号。
一个待处理信号最多只能被接受一次，内核为每个进程在 pending 位向量中维护着待处理信号的集合，只要传送了一个类型为 *k* 的信号，内核就会设置 pending 中的第 *k* 位，而只要接收了一个类型为 *k* 的信号，内核就会清除 pending 中的第 *k* 位。

一个进程可以有选择性的阻塞接收某种信号，内核在 blocked 位向量中维护着被阻塞的信号集合。

#### 发送信号
1) 进程组
每个进程只属于一个进程组，进程组是由一个正数进程组 ID 来标识的。
```C++
#include <unistd.h>

//返回调用进程的进程组的 ID
pid_t getpgrp(void);

//一个子进程默认和它的父进程属于同一个进程组
//将进程 pid 的进程组改为 pgid
//如果 pid 是 0，那么就使用当前进程的 PID
//如果 pgid 是 0，那么就使用 pid 指定的进程的 PID 作为进程组 ID
//如果成功，返回 0；否则返回 -1
int setpgid(pid_t pid, pid_t pgid);
```

2) 用 /bin/kill 程序发送信号
```C++
//程序可以向另外的进程发送任意的信号
//如果 PID 为负，信号就会被发送到进程组 PID 中的每个进程
Linux> /bin/kill -9 15213
```

3) 从键盘发送信号
作业：对一条命令行求值而创建的进程。
任何时刻，至多只有一个前台作业和 0 个或多个后台作业。
shell 为每个作业创建一个独立的进程组，进程组 ID 通常取自作业中父进程中的一个。

4) 用 kill 函数发送信号
进程可以通过`kill`函数发送信号给其他进程包括自己。
```C++
#include <sys/types.h>
#include <signal.h>

//如果 pid 大于零，kill 发送信号号码 sig 给进程 pid
//如果 pid 等于零，kill 发送信号 sig 给调用进程组中的每个进程，包括自己
//如果 pid 小于零，kill 发送信号 sig 给进程组 |pid| 中的每个进程
int kill(pid_t pid, int sig);
```

5) 用 alarm 函数发送信号
进程可以通过调用`alarm`函数向自己发送 SIGALRM 信号。
```C++ 
#include <unistd.h>

//内核在 secs 秒后发送一个 SIGALRM 信号给调用进程
//任何情况下，对 alarm 的调用都将取消任何待处理的（pending）闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数；如果没有任何待处理的闹钟，就返回 0
unsigned int alarm(unsigned int secs);
```


#### 接收信号
当内核把进程 p 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合（pending &~blocked）。
1) 如果这个集合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一条指令。
2) 如果集合是非空的，那么内核选择集合中的某个信号 k （通常是最小的 k），并且强制 p 接收信号 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令。每个信号类型都有一个预定义的默认行为，是下面中的一种：
* 进程终止。
* 进程终止并转储内存。
* 进程停止（挂起）直到被 SIGCONT 信号重启。
* 进程忽略该信号。

#### 阻塞和解除阻塞信号
1) 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号。
2) 显式阻塞机制：应用程序可以使用`sigprocmask`函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

#### 编写信号处理程序
处理程序很难推理分析的原因：
* 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰。
* 如何以及何时接收信号的规则常常有违人的直觉。
* 不同的系统有不同的信号处理语义。

1) 安全的信号处理
G0. 处理程序要尽可能简单。例如，处理程序可能只是简单地设置全局标志并立即返回。
G1. 在处理程序中只调用异步信号安全的函数，即能够被信号处理程序安全地调用。
* 可重入的，例如只访问局部变量。
* 不能被信号处理程序中断。
G2. 在进入处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。
G3. 阻塞所有的信号，保护对共享全局数据结构的访问。
G4. 用`volatile`声明全局变量。`volatile`限定符强迫编译器每次在代码中引用 g 时，都要从内存中读取 g 的值。
G5. 用`sig_atomic_t`声明标志。

2) 正确处理信号
为处理的信号不排队，如果已经有了一个类型为*k*的信号，则后来到达的类型为*k*的信号就会被丢弃。如果存在一个未处理的信号，则表明至少有一个信号到达了。

3) 可移植的信号处理


#### 非本地跳转
```C++
#include <setjmp.h>
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);

// 返回：setjmp 返回 0，longjmp 返回非零。
```
`setjmp`函数在`env`缓冲区中保存当前调用环境，以供后面的`longjmp`使用，并返回 0，返回值不能赋值给变量，但可以用在`switch`或条件语句的测试中。
```C++
#include <setjmp.h>

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);

// 从不返回。
```

`longjmp`函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 `setjmp`调用的返回。然后`setjmp`返回，并带有非零的返回值 retval。

`setjmp`函数只被调用一次，但返回多次：一次是当第一次调用`setjmp`，而调用环境保存在缓冲区 env 中时，一次是为每个相应的`longjmp`调用。
`longjmp`函数被调用一次，但从不返回。

**非本地跳转的应用**
* 允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。
* 使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。











