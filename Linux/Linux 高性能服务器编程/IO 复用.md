网络程序需要使用I/O复用技术的情况：
* 客户端需要同时处理多个 socket。
* 客户端程序要同时处理用户输入和网络连接。
* TCP 服务器要同时处理监听socket和连接socket。
* 服务器要同时处理TCP请求和UDP请求。
* 服务器要同时监听多个端口，或处理多种任务。

# socket
socket系统调用的用途：在一段指定时间内，监听用户感兴趣的文件描述符上的刻度、可写和异常等事件。

## select的tineout参数使用指针的原因？
因为内核将修改它以告诉应用程序select等待了多久。

## socket可读的情况
* socket内核接收缓冲区中的字节数大于或等于其低水位标记 SO_RCVLOWAT，此时可以无阻塞地读该socket，并且读操作返回的字节数大于0。
* socket通信的对方关闭连接，此时对该socket的读操作将返回0.
* 监听socket上有新的连接请求。
* socket上有未处理的错误，此时可以使用getsockopt来读取和清除该错误。

## socket可写的情况
* socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可以无阻塞地写该socket，并且写操作返回的字节数大于0.
* socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。
* socket使用非阻塞connect连接成功或者失败（超时）之后。
* socket上有未处理的错误，此时可以使用getsockopt来读取和清除该错误。

# poll
与socket类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。


# epoll
## epoll与select的区别
* epoll 使用一组函数来完成任务，而不是单个函数。
* epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像 select 和 poll 那样每次调用都要重复传入文件描述符或事件集，但 epoll 需要使用一个==额外的文件描述符==，来唯一标识内核中的这个事件表。
*  select每次调用都返回整个用户注册的事件集合，应用程序索引文件描述符的事件复杂度是 O(n)，而epoll仅返回就绪的事件，所以应用程序索引就绪文件描述符的时间复杂度是 O(1)。
* select只能工作在相对低效的[[IO 复用#LT与ET模式的区别|LT模式]]，而epoll可以工作在高效的[[IO 复用#LT与ET模式的区别|ET模式]]。
* select采用==轮询==的方式，每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给应用程序，因此检测就绪事件的时间复杂度是 O(n)；epoll采用==回调==的方式，内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列，内核最后在适当的时机将该就绪队列中的内容拷贝到用户空间，时间复杂度是 O(1)。
![[Pasted image 20220304194123.png]]


## LT与ET模式的区别
* 对于采用LT工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，==应用程序可以不立即处理该事件==，这样，当应用程序下一次调用 epoll-wait 时，epoll_wait 还会再次向应用程序告知此事件，直到该事件被处理。
* 对于采用ET工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，==应用程序必须立即处理该事件==，因为后续的 epoll_wait 调用将不再向应用程序通知这一事件。

ET模式很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比LT模式高。

每个使用ET模式的文件描述符都应该是非阻塞的，如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态。

EPOLLONESHOT：一个socket连接任一时刻都只被一个线程处理。
对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。