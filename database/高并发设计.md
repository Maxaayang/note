# 缓存

缓存的不足
- 缓存比较适合读多写少的业务场景，并且数据最好带有一定的热点属性
- 缓存会给整体系统带来复杂度，并且会有数据不一致的风险
- 缓存通常使用内存作为存储介质，但是内存并不是无限的
- 缓存会给运维带来一定的成本

## 旁路策略

比较适合搞一致性的场景

先更新数据库在更新缓存会造成缓存和数据库中的数据不一致，因为更新数据库和变更缓存是两个独立的操作，当两个线程并发更新它们时，就会因为写入顺序的不同造成数据的不一致。(==如果将它们变成不可分割的操作，是否还会存在这个问题？这个是否可以通过加锁来解决？==)

读策略
- 从缓存中读取数据
- 如果缓存命中，则直接返回数据
- 如果缓存不命中，则从数据库中查询数据
- 查询到数据后，将数据写入到缓存中，并且返回给用户

写策略
- 更新数据库中的记录
- 删除缓存记录(不删除的话, 当高并发时会造成大量的穿透, 从而导致雪崩)

旁路缓存不能先删除缓存，再进行数据库更新，因为很可能会出现缓存数据不一致的问题
先更新数据库后删除缓存理论上也是有缺陷的，可能会导致数据不一致，但是几率很小，因为缓存的写入往往远快于数据库的写入

==旁路缓存不能先更新数据库再更新缓存==
因为如果两个线程同时对数据库进行更新，如果先更新数据库的那个线程在更新缓存时出现了延迟，那么就会出现数据不一致的情况。

> [!faq] 在主从分离的情况下，如何解决因为延迟而导致读不到新数据的情况？
> 在插入新数据到数据库之后写入缓存

问题：当写入比较频繁时，缓存中的数据会被频繁的清理，从而对缓存的命中率有影响，==可能会造成缓存雪崩==
解决方案：
- 更新数据时也更新缓存，在更新缓存前先加一个分布式锁，这样在同一时间只允许一个线程更新缓存，就不会产生并发问题。(==在更新db的时候也要加锁，不然还会产生后来的B先拿到锁更新缓存的情况==)
- 在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响是可以接受的。

缺点：写操作会让缓存失效，再次读取时需要从数据库中加载

## Read/Write Through (读穿/写穿)策略

Write Through：先查询要写入的数据在缓存中是否已经存在，如果==已经存在==，则更新缓存中的数据，并且由缓存组件同步更新到数据库中

如果缓存中数据不存在(即 Write Miss)
- Write Allocate，写入缓存相应的位置，再由缓存组件同步更新到数据库
- No-write allocate，不写入缓存，直接更新到数据库中，==比 Write Allocate减少了一次缓存的写入，能够提升写入的性能==

缺点：需要缓存层支持和后端数据库的联动

## Write Back

写入数据时只写入缓存，并且把缓存块标记为"脏"的，脏块只有被再次使用时才会将其中的数据写入后端存储中。

如果出现了Write Miss，采用Write Allocate，即写入后端存储的同时也要写入缓存，这样之后的写请求只需要更新缓存即可，无需更新后端存储。

优点：写操作飞快(只写缓存)
缺点：如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致

这种策略经常使用在操作系统Page Cache中，或者应对大量写操作的数据库引擎中。