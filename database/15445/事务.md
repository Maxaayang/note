为什么保证原子性很难？
因为对数据库的一些修改可能仅仅存放在事务的主存变量中，而另一些可能已经被写入数据库并存储在磁磁盘上。


为什么需要原子性？
如果一个事务从未开始或者是保证完成，那么除了在该事务的执行期间，这样的不一致状态是不可见的，如果具有原子性，那么事务的所有操作要么在数据库中完全反映出来，要么根本不反映。


如何保证持久性？
* 由事务所执行的更新在事务结束前已经写入磁盘。
* 有关十五已执行的更新信息被写入磁盘，并且这些信息足以使数据库在故障后重新启动数据库系统时重建这些更新。

**补偿事务**是撤销已提交事务所造成的影响的唯一方式。

事务必须处于的为五种状态：
![[Pasted image 20220525164411.png]]

如果一个事务无法继续正常执行，就进入了失效的状态，必须进行回滚，并且事务进入中止状态，系统有两种处理方式：
* 重启事务：仅当那个引起事务中止的原因是某些硬件错误或者不是由于事务内部的逻辑而产生的错误，并且重启的事务是一个新事务。
* 杀死事务：通常是由于某些内部的逻辑错误，只有通过重写应用程序才可以改正这种错误，或者是由于输入错误，或者是由于所需数据在数据库中没有找到。


使用并发的好处：
* 提高吞吐量和资源利用率
* 减少等待时间


**冲突等价**：如果调度S可以经过一系列非冲突指令而转换成调度S'，则S与S'是等价的
**冲突可串行化**：调度S与一个串行调度是冲突等价的


如果关于调度S的优先图中有环，则调度S是非冲突可串行化的，否则就是冲突可串行化的。


**可恢复调度**：对于每个事务 T<sub>i</sub> 和 T<sub>j</sub>，如果 T<sub>j</sub> 读取了由 T<sub>i</sub> 之前所写的数据项，则 T<sub>i</sub> 的提交操作出现在 T<sub>j</sub> 的提交操作之前。


**级联回滚**：因单个事务失效而导致一系列事务回滚的现象。
**无级联调度**：对于每个事务 T<sub>i</sub> 和 T<sub>j</sub> 都满足如果 T<sub>j</sub> 读取了先前由 T<sub>i</sub> 所写的一个数据项，则 T<sub>i</sub> 的提交操作必须出现在 T<sub>j</sub> 这一读操作之前。
每一个无级联调度都是可恢复的。


==隔离级别==
![WJhc0e](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/WJhc0e.png)

* 可串行化
* 可重复读：只允许读取已提交的数据，并进一步要求在一个事务两次读取一个数据项期间，其他事务不得更新该数据项。但是，该事务对于其他事务来说可能不是可串行化的。例如，当一个事务在查找满足某些条件的数据时，它可能找到一些由一个已提交事务所插入的数据，但可能找不到由同一个事务所插入的其他数据。。
* 已提交读
* 未提交读

上边所有的隔离性级别附带都不允许脏写。


# 隔离性级别的实现
## 锁
事务可以只封锁它访问的那些数据，而不用封锁整个数据库
事务必须在足够长的时间内持有锁以保证可串行化，但是这一时期又要足够短以不会过度影响性能。

==两阶段锁==

共享锁和排它锁

## 时间戳
对于每个数据项，系统维护两个时间戳。数据项的**读时间戳**保留读取该数据的那些事务的最大时间戳。数据项的**写时间戳**保留写过该数据项当前值的事务的时间戳。

时间戳用来确保在事务访问冲突的情况下，事务按照事务时间戳的次序来访问每个数据项，当不能访问时，违例事务将会中止，并且分配一个新的时间戳重新开始。


## 多版本和快照隔离
在快照隔离中，每个事务在它开始时有其自己的数据库版本或快照，如果事务更新数据库的话，该更新只出现在其私有版本中，而不是在实际的数据库本身中，如果事务被提交，则和这些更新有关的信息被保存，使得这些更新被应用到正真的"数据库"。

当一个事务 T 进入部分提交状态时，只有在没有其他并发事务修改了 T 想要更新的数据项的情况下，T 才能进入提交状态。

==问题==：提供了太多的隔离
在快照隔离的情况下，存在任何事务都不能看到对方更新的情况。
如果 T 读取 T' 更新的某些数据项并且 T' 读取 T 更新的某些数据项，则可能两个事务都无法读取对方所做的更新。










