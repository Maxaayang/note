## 锁

- 互斥锁(mutex)：
	- 一次只能一个线程拥有互斥锁，其他线程只有等待
	- 互斥锁是抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文切换。互斥锁实际的效率还可以接受，加锁的时间大概100ns左右
	- 实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阈值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果不亚于自旋锁。
	- 互斥锁的开销主要体现在线程的**重新调度**和**上下文切换**上，获取锁的开销是比较大的，因此mutex适用于线程**持有锁时间比较长**的场景。
- 读写锁：
	- 多个读者可以同时进行读
	- 写者必须互斥
	- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
- 自旋锁(spinlock)：
	- 如果进线程无法取得锁，进程不会立即放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长期占有锁，那么自旋锁就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高
	- 优点：避免了操作系统的**重新调度**和**上下文切换**的开销
	- 缺点：在单处理器的场景下，如果锁已经被另一个线程持有，那么当前线程在尝试加锁时需要将整个时间片空转完毕。除非发生上下文切换，否则它是不可能获取到锁的，自旋锁可能会导致**饥饿**
	- 自旋锁的性能在多处理器的场景下不单处理器更好
- 条件锁：
	- 条件变量允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁只有锁定与非锁定两种状态的不足
	- 当某些执行状态不满足时，线程可以把自己加入队列，等待该条件
	- 条件变量常和互斥锁一起使用，以免出现竞态条件。当条件不满足的时候，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。
	- 总的来说，互斥锁是线程间互斥的机制，条件变量则是同步机制。
- 自适应锁：
	- 先执行自旋锁，不断持续尝试获取锁，如果尝试多次还是获取不到，就执行mutex操作，让线程进入睡眠

![[Pasted image 20221110155612.png]]

### 互斥锁，信号量的使用场景

### 信号量与互斥锁解决父子线程同时阻塞的区别

### 怎么实现自旋锁

### 锁的可重入与不可重入

## 死锁以及怎么解决死锁

### 死锁产生的四个条件

- 互斥：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待
- 非抢占：进程在所获得的资源未释放之前，不能被其他进程强行夺走，只能自己释放
- 持有并等待：进程持有了资源，同时又在等待其他资源
- 循环等待：进程之间存在一个环路，环路上的每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的

### 死锁预防

破坏上面四个条件的任意一个，但是很难实现

- 破坏互斥条件：允许某些资源同时被多个进程访问。但是==有些资源本身并不具有这种属性==，因此本方案实用性有限。
- 破坏非抢占条件：允许进程强行抢占被其他进程占有的资源，会降低系统的性能
- 破坏持有并等待条件：
	- 实行资源预先分配策略（当一个进程开始运行之前，必须一次性想系统申请他所需的全部资源，否则不运行）
	- 只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）
	- 缺点：很多时候无法预知一个进程所需的全部资；同时，会降低资源利用率，降低系统并发性
- 破坏循环等待条件：对所有的资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源，各个进程申请资源的顺序是从小到大的，就不会有环了

### 死锁避免

允许系统同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不发生则实施分配。银行家算法实现了这个过程


### 死锁检测

画出资源分配图，检测是否存在环路。检测环路前要将资源分配图化简，化简的原理是"一个目前占有运行所需的资源的进程，迟早能够执行完成释放资源"。因此可以从"进程-资源分配图"中找到一个既不阻塞又非孤立的进程，删除所有与该进程相连的有向边，回收资源，使之成为孤立节点，然后将所回收的资源分配给其它进程。循环此过程，直到无法化简。若仍存在环路，则该系统目前处于死锁状态。

检测到死锁后，需要解除死锁。

### 死锁解除

破坏除了"互斥条件"之外的三个条件
- 回退执行：系统定期对各个进程进行检查，将检查点的有关信息写入文件。死锁时，让某占有必要资源的进程回退到取得资源之前的一个检查点，释放的资源分配给一个死锁进程（破坏"占有且等待"）
- 抢占资源：剥夺占有进程的资源，分配给另外某些进程，直至死锁环路被打破（破坏"不可抢占"）
- 杀掉进程：一次终止一个进程，直至消除死锁环路（破坏"循环等待")

### 如何发现程序中的死锁
