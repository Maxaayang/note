## 陷阱、中断、异常、信号

### 异常控制流

每个进程对应的程序文件由一条一条的指令组成。进程在执行的时候。会将程序文件加载到进程的内存空间中，这些指令在内存空间中是相邻的。进程会通过调整程序计数器 PC 的值，一条一条地执行指令。我们将进程执行的指令序列叫做处理器的"控制流"。

正常情况下，进程可能会顺序执行相邻的指令，也可能通过跳转、调用、返回等程序指令转移到另一个位置开始执行。无论是前者还是后者，都是程序正常执行的结果，是可以预知的，符合预期的。

但是，系统中也会发生一些**异常情况**。处理这些异常的时候，会打断进程正常执行的控制流，转而执行相应的处理程序，执行完毕再返回，我们将这类突变称为 "异常控制流"

![-w471](https://imageslr.com/media/15948281929782.jpg)

异常控制流的形式有以下几种：陷阱、中断、异常，此外还有信号，这是一种更高层的异常形式，也会改变进程的控制流。

### 陷阱

陷阱是有意造成的异常，是执行一条指令的结果。**陷阱是同步的**。

**陷阱的主要作用是实现系统调用**。比如，进程可以 syscall n 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。

每个系统调用有一个唯一的整数号，对应于内核中的一个跳转表的偏移量。这个跳转表中的每一个条目表示一个系统调用的代码位置。执行系统调用时，通过这个整数号作为跳转表的偏移量，就可以执行相应的系统调用。

![sq6PFu](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/sq6PFu.png)

陷阱也被称为"软中断"，它不是真正意义上的中断，但是和硬件中断的处理流程类似。

### 中断

中断由处理器**外部**的**硬件**产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此**中断是异步事件**。

中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。

每个中断都有一个中断号。操作系统使用**中断描述符表**（Interrupt Descriptor Table，IDT）来保存每个中断的中断处理程序的地址。当发生中断时，操作系统会根据中断号，在中断描述表中查找并执行相应的中断处理程序。当处理程序返回后，进程继续执行**下一条指令**，就好像没有发生过中断一样。

![TGag55](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/TGag55.png)

#### 软中断

原因:中断请求的处理程序应该要短且快，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。

Linux 系统**为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。**

- **上半部直接处理硬件请求，也就是硬中断。用来快速处理中断**，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。负责耗时短的工作，特点是快速执行；
- **下半部由内核触发，也就说软中断。用来延迟处理上半部未完成的工作**，一般以「内核线程」的方式运行。通常都是耗时比较长的事情，特点是延迟执行；

### 异常

异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。**异常是同步的**。

注意这里的“异常”和上文一开始说的“异常”的区别。上文的“异常”是一个通用的术语，表示因为某些事件/操作而引起的控制流的改变，包括陷阱、中断和异常。这里的“异常”特指因为执行当前指令而产生的**错误情况**，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为 **“故障”**。

当发生异常时，操作系统会将控制转移给相应的异常处理程序。如果处理程序能够修正这个错误情况，就将返回到**引起异常的指令**重新执行。否则，**终止**该应用程序。

异常处理程序的地址也保存在中断描述符表（IDT）中。

![-w494](https://imageslr.com/media/15948647387834.jpg)

常见的异常类型及处理：
- 除法错误（异常 0）：当应用程序试图除以零，或者一个除法指令结果溢出的时候，就会发生除法错误。Linux 会**直接终止**程序。Linux shell 报告为“浮点异常（Floating exception）”
- 一般保护故障（异常 13）：当应用程序访问一个未定义的虚拟内存区域（如访问空指针），或者试图写一个只读的文本段时，会发生一般保护故障。Linux 会**直接终止**程序。Linux shell 报告为“段错误（Segmantation fault）”
- 缺页异常（异常 14）：当应用程序访问未加载的页面时，会引起缺页异常。缺页处理程序会加载适当的页面，然后**重新执行**引起异常的指令

![GU6ilj](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/GU6ilj.png)

==中断与异常的异同==
1. 相同点
	- 最后都是由CPU发送给内核，由内核去处理
	- 处理程序的流程设计上是相似的
2. 不同点
	- 产生源不同，异常是由CPU产生的，而中断是由硬件设备产生的
	- 内核需要根据是异常还是中断调用不同的处理程序
	- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
	- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中
	- 硬中断和软中断（只要是中断上下文）执行的时候都不允许内核抢占

### 信号

信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程来进行处理一个信号代表了一个消息。**信号的作用是用来通知进程发生了某种系统事件**。

信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以用它来通知用户空间进程发生了哪些系统事件。

上文的陷阱、中断和异常都是低层异常机制，由内核的异常处理程序进行处理，正常情况下对用户进程是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除0，那么内核会收到一个除零的异常，内核会给进程发送一个 SIGFPE 信号(=8)，如果一进程非法内存访问，那么内核会收到一个一般保护故障，内核会给进程发送一个 SIGSEGV 信号(=11)

此外，还有其他系统事件。也可以通过信号来通知进程。比如，如果按下 Ctrl + C，那么内核会给进程发送一个 SIGINT 信号

#### 发送信号

信号除了由内核发给进程，也可以作为进程间通信的一种方式，明确由一个进程发送给另一个进程

发送信号的机制：
- 用 /bin/kill 程序发送信号
- 从键盘发送信号，比如按下 Ctrl + C 发送 SIGINT 信号、按下 Ctrl + Z 发送 SIGTSTP 信号
- 用 kill 函数发送信号
- 用 alarm 函数向自己发送 SIGALARM 信号

#### 接收信号

每个进程有一个待处理信号的集合。待处理信号表示发送给该进程但是还未被处理(接收)的信号，任何时刻同一类型的待处理信号最多只有一个，后续发送的同类型信号将会被丢弃(隐式阻塞)

进程也可以选择阻塞某种信号。当一种信号被阻塞时，它仍可以被发送，但产生的待处理信号不会被目标进程接收，直到进程取消对这种信号的阻塞(显式阻塞)

#### 处理信号

信号处理的时机
- 当内核把进程**从内核态切换到用户态时**。例如，从系统调用返回，或是完成一次上下文切换
- 内核通过**控制转移**来强制进程 _接收/处理_ 信号。如果进程的未被阻塞的待处理信号集合不为空，则内核会选择集合中的某个信号（通常是最小的），并将控制传递到信号处理程序；否则，内核正常地将控制传递到进程的下一条指令

用户进程对信号的处理过程有三种：
1.  执行默认操作，linux 对每种信号都规定了**默认行为**（见上图），是下面的一种
    -   进程终止
    -   进程终止并转储内存（core dump）
    -   进程停止（挂起）直到被 SIGCONT 信号重启
    -   进程忽略该信号
2.  忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理
3.  处理信号。定义信号处理程序，当信号发生时，执行相应的处理程序

信号处理程序是一个**用户层函数**。进程可以为某个信号指定一个信号处理程序，接收到信号后，进程会跳转执行信号处理程序，执行完成后再返回到中断位置的**下一条指令**继续执行。

![-w407](https://imageslr.com/media/15949144782600.jpg)

