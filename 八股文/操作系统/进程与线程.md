## 进程与线程
### 进程






### 线程

#### 为什么需要线程

进程切换是一个开销很大的操作。进程切换的开销主要包括：
- 处理机的上下文切换：保存和恢复相关寄存器的内容
- 与进程相关的数据结构的更改：存储管理有关的记录信息（如页表）、文件管理有关数据（如文件描述符）、进程控制块中的各种队列（如阻塞队列、就绪队列、通信队列）等

进程的处理机资源和其他的资源是一起分配的，进程切换的时候会整体切换，开销很大。如果我们**只切换必须的、与处理机相关的信息**，就可以有效减少开销。这种情况下，处理机分配的单位和其他的资源分配的单位不能再是一个实体

由此引入线程：把一个进程分为多个执行任务的单元体，只为其分配处理机，这些执行任务的单元体就是线程

#### 线程的上下文切换

线程有自己的寄存器和栈，当上下文切换时，正在运行的线程会将寄存器的状态保存到TCB(Thread Control Block)里(进程是PCB, Proxess Control Block)，然后恢复另一个线程的上下文

与进程的区别是，线程只需要切换处理机执行的上下文，不帮助改变地址空间。这意味着：
- 不需要重新加载页表，切换开销少，提高效率
- 多个线程共享地址空间，有利有弊

![15941873964798.jpg](https://imageslr.com/media/15941873964798.jpg)

#### 线程的优缺点

优点：
- 提高效率：切换开销小
- 通信方便，共享内存；进程必须通过进程间通信==IPC==
- 各个线程之间可以并发执行，提高程序并发性
- 多个线程是IO密集型时，多线程可以使这些活动彼此重叠运行，可以加快程序的执行速度。

缺点：
- 一个线程出错，操作系统会结束整个进程，不够健壮；而多进程没有这个问题
- 同一个进程中的多个线程共享内存，会有并发问题

#### 同一进程中的线程共享与独占的资源

共享资源：
- 内存空间
	- 代码
	- 公共数据（全局变量、静态变量）
	- 堆
- 文件描述符
- 信号处理器
- 进程 ID / 进程组 ID
- ...

独占资源，以及为什么需要独占：
- 线程ID：在本进程中唯一，进程用来标识此线程
- 一组寄存器的值
- 栈：每个线程中的函数调用过程是独立的，因此需要有独立的栈
- 错误返回码：系统调用或库函数发生错误时，会设置全局errno，各个线程的错误返回码应该是独立的
- 信号屏蔽码：每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由自己管理；但每个线程都共享本进程的信号处理器

#### 线程的实现方式

线程也像进程一样有多个状态：运行、就绪、阻塞 ...

从Linux内核的角度看，线程和进程并没有被区别对待。无论线程还是进程，都是用 task_struct 结构表示的，只不过线程的 mm(内存空间)和 files(打开的文件)结构体是共享的。

线程实现的方式有三种：
- 在内核实现：在内核中实现的线程，是由内核管理的线程
- 在用户空间实现：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理
- 混合方式实现(轻量级进程)：在内核中来支持用户线程

##### 用户线程

用户线程是基于用户态的线程管理库来实现的，那么**线程控制块**也是在库里面来实现的，对于操作系统而言是看不到这个TCB的，它只能看到整个进程的PCB。所以用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。

优点：
- 每个进程都需要有它私有的线程控制块(TCB)列表，用来跟踪记录它各个线程状态信息(PC、栈、指针、寄存器)，TCB由用户级线程库函数来维护，可用于不支持线程技术的操作系统
- 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快
- 允许每个进程有自己的调度算法
- 具有较好的可扩展性，因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大，就会出现问题
- 线程能够利用的表空间和堆栈空间比内核线程多

缺点：
- 由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了
- 当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的
- 由于时间片分配给进程，故与其他进程相比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢

##### 内核线程

内核线程是由操作系统管理的，线程对应的TCB放在操作系统里，这样线程的创建、终止和管理都是由操作系统负责

优点：
- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行
- 时间片分配给线程，多线程的进程获得更多的CPU运行时间

缺点：
- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如PCB 和 TCB
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大

##### 轻量级进程

轻量级进程（LWP）是内核支持的用户线程，一个进程可以有一个或多个LWP，每个LWP是跟内核线程一对一映射的，也就是LWP都是由一个内核线程支持

LWP与普通进程的区别在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而LWP代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以LWP也不带有这样的信息。

在LWP之上也是可以使用用户线程的，那么LWP与用户线程的对应关系就有三种
- 1：1，即一个LWP对应一个用户线程
- N：1，即一个LWP对应多个用户线程
- M：N，即多个LWP对应大哥用户线程

**1：1 模式**
一个线程对应到一个LWP再对应到一个内核线程
优点：实现并行，当一个LWP阻塞，不会影响其他LWP
缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大

**N：1 模式**
多个用户线程对应一个LWP再对应一个内核线程，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见
优点：用户线程要开几个都没问题，且上下文切换发生在用户空间，切换的效率较高
缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核CPU中，是没办法充分利用CPU的

**M：N 模式**
根据前面的两个模型混搭在一起，就形成 M：N 模型，该模型提供了两级控制，首先多个用户线程对应到多个LWP，LWP再一一对应到内核线程
优点：综合了前两种优点，大部分的线程上下文切换发生在用户空间，且多个线程又可以充分利用多核CPU的资源。

##### 用户级线程与内核级线程的区别

- 内核级线程是OS内核可感知的，而用户级线程是OS内核不可感知的
- 用户级线程的创建、撤销和调度不需要OS内核的支持，是在语言这一级处理的；内核级线程创建、撤销和调度都需OS内核提供支持，而且与进程的创建、撤销和调度大体是相同的
- 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核级线程执行系统调用指令时，只导致该线程被中断
- 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，有用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度
- 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序

#### 如何回收线程

-   等待线程结束：int pthread_join(pthread_t tid, void** retval);
    - 主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。
        - tid：创建线程时通过指针得到tid值。
        - retval：指向返回值的指针。
    - 结束线程：pthread_exit(void \*retval);
    - 子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。
        - retval：同上。

- 分离线程：int pthread_detach(pthread_t tid);
    - 主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。
    - tid：同上。


## 进程的调度
### 进程的状态
#### 基本状态

就绪、执行、睡眠
- 就绪：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 执行：进程正在占用处理机资源执行
- 阻塞：进程等待某种条件，在条件满足之前我无法执行。如发起 I/O 系统调用，会被阻塞，等待 I/O 中断发生


![](https://vl67qv51dr.feishu.cn/space/api/box/stream/download/asynccode/?code=YmUxM2RiYjNmMjAyODM5MWJjNzE1YTQ1NjdmMGJjNjFfUktONEhsTkp4eHVxaWRPbldwRnlVbkF5dTd4RUE5cUVfVG9rZW46Ym94Y253eFRSR3lCeFlsS290V3RoMWYzanpjXzE2Njg1ODIwOTc6MTY2ODU4NTY5N19WNA)

应该注意以下内容：
- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。

那么，就需要一个新的状态，来**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。
-   **阻塞挂起状态**：进程在外存（硬盘）并等待某个事件的出现；
-   **就绪挂起状态**：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

**只有就绪态和运行态可以相互转换，其它都是单项转换**

### 挂起

"挂起"是将暂不执行的进程换出到外存，节省内存空间

"挂起"和"阻塞"都是进程暂停执行的状态，但是却是两个维度的概念
- 阻塞表示进程正在等待一个事件的发生，阻塞状态下收到信号会切换到就绪状态
- 挂起表示进程被换出到外存，挂起状态下被激活时会被载入到内存，切换为非挂起状态

挂起状态的进程按照是否阻塞可以分为：
- 挂起就绪状态：进程在外存，但是只要被载入内存就可以执行
- 挂起阻塞状态：进程在外存中并等待一个时间，即使被载入内存（激活）也无法运行

![[Pasted image 20221114092329.png]]

### 睡眠

Linux将进程的阻塞状态进一步细分为：暂停、浅睡眠、深睡眠。其中，若不需要等待资源，则切换为"暂停"；若需要等待资源，切换为"睡眠"；如果睡眠状态能被唤醒，则是"浅睡眠"，否则是"深睡眠"

![[Pasted image 20221114092546.png]]

### 挂起、阻塞、睡眠的区别

从触发机制上：
-   睡眠是主动触发的，
-   挂起也是主动触发
-   而阻塞是被动的

从资源占用角度来说：
- 阻塞进程不再占用CPU资源，但还在占用调度器和内存资源
- 挂起进程不再占用CPU和内存资源了
- 睡眠进程既占用内存资源又占用CPU资源
- 从恢复上来看： 睡眠恢复是自动完成的，因为睡眠有一个睡眠时间，睡眠时间到则恢复到就绪态。
- 阻塞是被动的，是在等待某种事件或者资源的表现，一旦获得所需资源或者事件信息就自动回到就绪态。
- 最后挂起情况最多，如果是用户将进程挂起的话，那么只有用户才能解除进程的挂起状态，而如果是被操作系统挂起的，这要根据系统资源情况，优先级，挂起中的状态来判定什么时候解除挂起状态。

### 进程控制块

**进程控制块/表（PCB）来描述进程，PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

一般会选择链表进行组织，把具有**相同状态的进程链在一起，组成各种队列****。**因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

**组成（包含进程上下文信息）：**
-   **进程描述信息**
    -   进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
    -   用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

-   **进程控制和管理信息**
    -   进程当前状态，如 new、ready、running、waiting 或 blocked 等；
    -   进程优先级：进程抢占 CPU 时的优先级；

-   **资源分配清单**
    -   有关内存地址空间或虚拟地址空间的信息（如页表基地址），所打开文件的列表和所使用的 I/O 设备信息。

-   **CPU 相关信息：**
    -   CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

> 线程控制块 TCB 中包含了哪些内容？
>
> -   线程标识符
> -   一组寄存器
>     -   通用寄存器
>     -   程序计数器PC
>     -   状态寄存器
> -   线程运行状态
> -   优先级
> -   线程专有存储区
> -   信号屏蔽
> -   堆栈指针

### 进程的上下文切换

操作系统需要事先帮 CPU 设置好 **CPU 寄存器和程序计数器，**CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文。**

进程是由内核管理和调度的，所以进程的切换只能发生在**内核态**。

所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中。

#### 上下文切换的场景

- 时间片耗尽，进程从运行状态变为就绪状态
- 资源不足，等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行
- sleep主动挂起
- 有优先级更高的进程运行时，当前进程会被挂起，由高优先级进程来运行
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

### 调度算法

#### 调度算法的分类

- 按照CPU的分配方式：非抢占式、抢占式
- 按照系统的分时方式：在批处理系统，交互系统或实时系统下的调度

#### 饥饿问题

某个进程无限等待，无法被调度

#### 批处理系统的调度算法

调度算法的目标：
- 吞吐量：系统每小时完成的作业数，要尽可能多
- 周转时间：一个作业从提交到完成时的统计平均时间
- CPU利用率：由于没有交互，CPU不会出现等待输入的情况，银保吃CPU利用率要高

##### 先来先服务（First Come First Serverd, FCFS）

- 按照请求CPU的顺序使用CPU，非抢占式
- 优点是易于理解，便于实现，只需一个就绪队列
- 缺点是对短作业不公平；对 I/O 密集型进程不利，长时间等待设备；响应时间不确定

##### 最短作业优先

- 预知作业的运行时间，选择最短时间的优先运行
- 优点是提高平均周转时间
- 缺点是对长作业不公平；可能导致饥饿问题

##### 最短剩余时间优先

- 最短作业的抢占式版本，如果新作业比正在执行的作业剩余时间短，则它优先执行
- 缺点是对长作业不公平；可能导致饥饿。同"最短作业优先"

##### 最高响应比优先

- 响应比的定义：作业等待时间 / 作业运行所需时间
- 哪个进程的响应比大，哪个进程优先
- 由响应比的定义可以知道，作业运行所需时间越小、作业等待时间越长，响应比越大
- 优点：同时考虑了等待时间和执行时间，既优先考虑短作业，也防止长作业无限等待的饥饿。

#### 交互系统(分时系统)的调度算法

调度算法的目标：
- 响应时间：要快速响应交互请求
- CPU的运行分为若干个时间片，能够处理不同的运算请求，使每个用户都能共享主机资源

##### 时间片轮转

- 将所有就绪的进程排成一个队列，按照时间片轮流调度，用完时间片的进程排到队列末尾，属于抢占式
- 优点：没有饥饿问题
- 问题：若时间片小，进程切换频繁，吞吐量低；若时间片长，则响应时间过长，实时性得不到保证

##### 优先级调度算法

- 优先级高的进程先运行，同优先级的进程轮转。当高优先级队列中没有进程后，再调度下一级队列
- 缺点是可能导致低优先级进程饿死

引入**动态设定优先级的思想**：在优先级高的进程运行一个时间片后，降低其优先级，防止其一直占用CPU，饿死低优先级的进程。结合这个思想，可设计出"多级反馈队列"

##### 多级反馈队列

有许多独立的队列，每个队列有不同的优先级

- 优先级高的队列先执行；**优先级越高，时间片越短**；如果一个进程在当前队列规定的时间片内无法执行完毕，则移动到下一个队列的队尾
- 缺点是也有可能出现饥饿问题，比如不断有新的更高优先级的进程加入
	- 解决方案：经过一段时间S，就将系统中所有工作重新加入最高优先级队列

使用时间片的一个缺点，如果程序在每个时间片快要用完之前主动放弃CPU，那么他就会一直处于高优先级
解决方案：使用时间配额而不是时间片

##### 彩票法

彩票数代表了进程占有某个资源的份额，一个进程拥有的彩票数占总彩票数的百分比就是它占有资源的份额。

调度程序从总的票数中抽取中奖彩票，拥有这个数对应的彩票的进程中奖

随机方法的优点
- 可以避免奇怪的边角问题，例如LRU在有重复序列的负载时表现非常差
- 轻量，几乎不需要记录任何状态
- 很快，只要可以很快地产生随机数，做出决策就很快

- 向进程提供各种系统资源的彩票，调度是随机抽取彩票，拥有该彩票的进程得到资源
- 可给重要的进程更多的彩票；协作进程可以交换彩票
- 缺点是在工作运行时间很短的情况下，经常不能产生正确的bili
	- 解决方案：步长调度，一个确定性的公平分配算法
	- 使用一个大数分别除以每个进程的票数来获得每个进程的步长
	- 选择目前拥有最小行程值的进程，并且运行之后将该进程的行程值增加一个步长
- 彩票调度不需要全局状态，而步长调度需要拥有全局状态

这两种方式没有作为CPU的调度程序被广泛使用
- 这两种方式都不能很好地适合 I/O
- 最难的票数分配问题并没有确定的解决方式

##### 公平共享法

- 为每用户分配一定比例的CPU时间，而不是按照进程
- 各用户之间按照比例挑选进程

#### 实时系统的调度算法

调度算法的目标：满足任务的截止时间。也就是说，如果有一个任务需要执行，实时操作系统会马上执行该任务，并不会有较长的延时

##### 最早截止时间优先算法

先把截止时间早的任务给完成，否则这个任务如果在截止时间后才完成，就没有意义了

### 僵尸进程、孤儿进程、守护进程

- 僵尸进程：停止运行
- 孤儿进程：正在运行
- 守护进程：正在运行

#### 僵尸进程

当一个进程由于某种原因终止时，内核并不是把它从系统中清除。进程会保持在一种"已终止"的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核会抛弃已终止的进程，此时该进程就不存在了。

僵尸进程是指终止但还未被回收的进程，如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()` 来回收，那么就会产生僵尸进程。僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中。

危害：占用进程号，系统所能使用的进程号是有限的，可能导致不能产生新的进程；占用一定的内存

如何避免产生僵尸进程：
- 通过`signal(SIGCLD, SIG_IGN)` 通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：`signal(SIGCLD, SIG_IGN)` ，表示父进程忽略SIGHLD信号，该信号是子进程退出的时候向父进程发送的
- 父进程调用 `wait()` 或者  `waitpid()` 等待子进程结束，如果尚无子进程退出，wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回
- 如果父进程很忙，可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出
- 通过两次调用fork，父进程首先调用fork创建一个子进程，然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程，其父进程已经退出，所以孙子进程就成为了一个孤儿进程，孤儿进程由Init进程接管，孙子进程结束后，Init会等待回收

第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。

**设置僵尸进程的目的**是维护子进程的信息，以便父进程在以后的某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以获得这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程id将被重置为1(init进程)。继承这些子进程的init进程将清理他们(也就是说Init进程将wait他们，从而去除他们的僵尸状态)

#### 孤儿进程

如果某个进程的父进程先结束了，那么它的子进程会成为孤儿进程，每个进程结束的时候，学习通都会扫描是否存在子进程，如果有，则用 Init 进程(pid = 1) 接管，并由 Init 进程调用 `wait` 等待其结束，完成状态收集工作。孤儿进程不会对系统造成危害。

#### 守护进程

守护进程是一种在后台周期性执行某种任务的进程，独立于控制终端。

## 进程间的通信方式

| 方式     | 传输的信息量       | 使用场景       | 关键词                                                         |
| -------- | ------------------ | -------------- | -------------------------------------------------------------- |
| 信号     | 少量               | 任何           | 硬件来源、软件来源信号队列                                     |
| 管道     | 少量               | 亲缘进程间               | 单向流动/内核缓冲区/循环队列/没有格式的字节流/操作系统负责同步 |
| 命名管道 | 大量               | 任何           | 磁盘文件/访问权限/无数据块/内核缓冲区/操作系统负责同步         |
| 信号量   | N                  | 任何           | 互斥同步/原子性/P减V增                                         |
| 共享内存 | 大量               | 多个进程       | 内存映射/简单快速/操作系统不保证同步                           |
| 消息队列 | 比信号多，但有限制 | 任何           | 有格式/按消息类型过滤/操作系统负责同步                         |
| 套接字   | 大量               | 不同主机的进程 | 读缓冲区/写缓冲区/操作系统负责同步                             |

### 信号

[[操作系统#信号|信号]]是Linux系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以才去自定义的行为。这是一种"订阅-发布"的模式

信号的来源分为硬件来源和软件来源
- 硬件来源：如按下 CTRL+C、除0、非法内存访问等等
- 软件来源：如Kill命令、Alarm Clock超时、当Reader终止后又向管道写数据等等

一般的信号是都是由一个错误产生的。以除 0 为例。在 x86 机器上 DIV 或 IDIV 指令除数为 0 时，会引发 0 号中断，编号 \#DE(Divide Error)，即所谓除零异常。这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT 中的中断处理程序。而操作系统处理这个异常的方法，就是**向进程发送一个信号 `SIGFPE`**。如果进程设置了相应的 signal handler，就执行进程的处理方法。否则，执行操作系统的默认操作，一般这种信号的默认操作是杀死进程。

同理，溢出、非法内存访问（越界）、非法指令等也都属于硬件中断，由操作系统处理。**操作系统会将这些硬件异常包装成“信号”发送给进程**。如果进程不处理这几个异常信号，那么默认的行为就是挂掉。

但是，信号也可以作为进程间通信的一种方式，明确地由一个进程发送给另一个进程。

进程如何发送信号？
- 操作系统提供发送信号的系统调用
- 该系统调用会将信号放到目标进程的**信号队列**中
- 如果目标进程未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程

进程如何接收信号？
- 每个进程有一个**信号队列**，放其他进程发给它、等待它处理的信号
- 进程在执行过程中的特定时刻，检查并处理自己的信号队列。如从系统空间返回到用户空间之前
- 发送信号时，必须指明发送目标进程的号码。一般用在具有亲缘关系的进程之间

用户进程对信号的处理过程有三种：
1. 处理信号。定义信号处理函数，当信号发生时，执行相应的处理函数
2. 忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理
3. 不处理也不忽略。执行默认操作，linux 对每种信号都规定了默认操作

有的信号，用户进程是无法处理也无法忽略的，比如`SIGSTOP`、`SIGKILL` 等。

### 管道

管道命令，在 Linux Shell 中经常使用，一般，我们使用管道操作符 `|` 来表示两个命令之间的数据通信。比如：

```
ps -ef | grep java | xargs echo
```

管道操作符的内部实现其实就是 Linux 的管道接口。由管道操作符 `|` 分割的每个命令是独立的进程，各个进程的标准输出 STDOUT，会作为下一个进程的标准输入 STDIN。

#### 定义

管道是一种半双工的通信方式，数据只能**单向流动**，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，那么需要建立两个管道。

管道适合于**传输大量信息**。管道发送的内容是以字节为单位的，**没有格式的字节流**。

#### 创建管道

通过 `pipe()` 系统调用来创建并打开一个管道，当最后一个使用它的进程关闭对他的引用时，pipe 将自动撤销。

通过 `pipe()` 创建的是匿名管道，只能用于具有亲缘关系的进程之间（父子进程或兄弟进程）。

#### 管道的实现

**管道就是一个文件**，是一种只存在于内存中的特殊的文件系统。

在 Linux 中，管道借助了文件系统的 File 结构实现。父进程使用 File 结构保存向管道写入数据的例程地址，子进程保存从管道读出数据的例程地址。这解释了上文所说的：

1.  单向流动
2.  只能用于具有亲缘关系的进程之间

管道是由内核管理的一个缓冲区，缓冲区被设计成为环形的数据结构，以便管道可以被循环利用（循环队列）。

#### 管道的同步

管道是一个具有特定大小的缓冲区
- 操作系统会保证读写进程的同步
- 下游进程或者上游进程需要等另一方释放锁后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问
- 当管道为空时，下游进程读阻塞；当管道满时，上游进程写阻塞
- 管道不再被任何进程使用时，自动消失

#### 管道的读写

- 读操作
	- 有数据
		- read 正常读，返回读出的字节数
	- 无数据
		- 写端全部关闭
			- read解除阻塞，返回0，相当于读文件读到了尾部
		- 没有全部关闭
			- read阻塞
- 写操作
	- 读端全部关闭
		- 管道破裂，进程终止，内核给当前进程发SIGPIPE信号
	- 读端没全部关闭
		- 缓冲区写满了
			- write阻塞
		- 缓冲区没满
			- 继续write

若是读端设置为非阻塞
- 写端没有关闭，管道中没有数据可读，则read返回-1
- 写端没有关闭，管道中有数据可读，则read返回实际读到的字节数
- 写端已经关闭，管道中有数据可读，则read返回实际读到的字节数
- 写端已经关闭，管道中没有数据可读，则read返回0

### 命名管道

Linux 管道包含匿名管道和命名管道。上面说的是匿名管道，只能用在亲缘进程中，管道文件信息保存在内存里。

命名管道（FIFO）可用于没有亲缘的进程间。Pipe 和 FIFO 除了建立、打开、删除的方式不同外，二者几乎一模一样。

通过 `mknode()` 系统调用或者 `mkfifo()` 函数建立命名管道。一旦建立，任何有访问权的进程都可以通过文件名将其打开和进行读写，而不局限于父子进程。

建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过**内核缓冲区**来实现数据传输。有访问权限的进程，可以通过磁盘的索引节点来读写这块缓冲区。

当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在。

### 信号量

信号量是一种特殊的变量，对它的操作都是原子的，有两种操作：V（`signal()`）和 P（`wait()`）。V 操作会增加信号量 S 的数值，P 操作会减少它。

-   V(S)：如果有其他进程因等待 S 而被挂起，就让它恢复运行，否则 S 加 1
-   P(S)：如果 S 为 0，则挂起进程，否则 S 减 1

P、V 来自于荷兰语：Probeer (try)、Verhoog (increment)。

如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore）。在 Linux 系统中，二进制信号量又称互斥锁（Mutex）。信号量可以用于实现进程或线程的互斥和同步。

信号量在底层的实现是通过硬件提供的原子指令，如 `Test And Set`、`Compare And Swap` 等。比如 golang 实现互斥量就是使用了 `Compare And Swap` 指令（[github](https://github.com/golang/go/blob/master/src/sync/mutex.go#L72)）。

### 共享内存

共享内存顾名思义，允许两个或多个进程共享同一段物理内存。**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它**。不同进程可以通过向共享内存端读写数据来交换信息。

一个进程可以通过操作系统的系统调用，创建一块共享内存区；其他进程通过系统调用把这段内存映射到自己的用户地址空间中；之后各个进程向读写正常内存一样，读写共享内存。共享内存区只会驻留在创建它的进程地址空间内。

**共享内存的优点是简单且高效**，访问共享内存区域和访问进程独有的内存区域一样**快**，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制。

比如管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件（[图示](https://cloud.tencent.com/developer/article/1021157)）。此外，消息传递的实现经常采用系统调用，也就经常需要用户态和内核态互相转换；而共享内存只在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。

**共享内存的缺点是存在并发问题**，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。

Linux 的 2.2.x 内核支持多种共享内存方式，如 mmap() 系统调用，Posix 共享内存，以及系统 V 共享内存。

mmap() 系统调用的主要作用是将**普通文件**映射到进程的地址空间，然后可以像访问普通内存一样对文件进行访问，不必再调用 read()，write() 等操作。mmap() 不是专门用来共享内存的，但是多个进程可以通过 mmap() 映射同一个普通文件，来实现共享内存。

system V 则是通过映射**特殊文件**系统 shm 中的文件实现进程间的共享内存。通过 shmget 可以创建或获得共享内存的标识符。取得共享内存标识符后，通过 shmat 将这个内存区映射到本进程的虚拟地址空间。

有关 mmap() 系统调用、system V 共享内存的详细介绍，以及两者的对比，可以进一步查看这两篇文章：

### 消息队列

**消息队列是一个消息的链表**，保存在内核中。消息队列中的每个消息都是一个**数据块**，具有特定的格式。操作系统中可以存在多个消息队列，每个消息队列有唯一的 **key**，称为消息队列标识符。

消息队列**克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点**。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了**有格式**的数据，但消息队列仍然有大小限制。

消息队列允许一个或多个进程向它写入与读取消息。消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。也就是说，消息队列是**异步**的，但这也造成了一个缺点，就是接收者必须**轮询**消息队列，才能收到最近的消息。

操作系统提供创建消息队列、取消息、发消息等系统调用。

操作系统负责读写同步：若消息队列已满，则写消息进程排队等待；若取消息进程没有找到需要的消息，则在等待队列中寻找。

消息队列和管道相比，相同点在于二者都是通过发送-接收的方式进行通信，并且数据都有最大长度限制。不同点在于消息队列的数据是有格式的，并且**取消息进程可以选择接收特定类型的消息**，而不是像管道中那样默认全部接收。

与FIFO相比，消息队列的优点
- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
- 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收

特点：
- 消息队列是保存在内核中的消息链表，每个消息体都是固定大小的存储块。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除
- 如果没有释放消息体队列或者没有关闭操作系统，消息队列就会一直存在

缺点：
- 通信不及时，附件有大小限制
- 不适合比较大数据的传输，每个消息体都有一个最大长度的限制，同时所有队列包含的全部消息体的总长度也有上限
- 存在用户态与内核态之间的数据拷贝开销

### 套接字 Socket

- 不同的计算机的进程之间通过 socket 通信，_也可用于同一台计算机的不同进程_
- 需要通信的进程之间首先要各自创建一个 socket，**内容包括主机地址与端口号**，声明自己接收来自某端口地址的数据
- 进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程

操作系统提供创建 socket、发送、接收的系统调用，为每个 socket 设置发送缓冲区、接收缓冲区。

### 进程通信与线程通信有什么不同


