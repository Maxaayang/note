## 虚拟地址空间的组成部分

整体上，操作系统将每个进程的虚拟地址空间划分成两个部分：内核空间和用户空间。内核空间存放的是内核代码和数据，用户空间存放的是用户程序的代码和数据。在32位操作系统中，一般是将最高的1G字节作为内核空间，而将较低的3G字节作为用户空间。

进程运行在内核空间时，处于内核态，此时可以执行任何特权指令。每个进程的内核空间都是相同的，用户代码无法访问内核空间。

虚拟地址空间的完整组成

![i691Vq](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/i691Vq.png)

从上往下依次是：
- 内核虚拟内存：所有进程共享内核的代码和全局数据结构，独享与进程相关的数据结构，Linux会将内核虚拟内存的共享区域映射到被所有进程共享的物理页面上
- 用户栈：从高地址向低地址增长
- 共享库：动态链接阶段
- 运行时堆：从低地址向高地址增长
- 程序代码和数据：从可执行文件中加载(代码段、数据段、BSS段)

### 栈

用户栈起始就是函数调用栈，作用主要是：
- 保存函数的局部变量
- 保存某些寄存器的值
- 向被调用函数传递参数
- 返回函数的返回值
- 保存函数的返回值

每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值，这块栈内存为该函数的栈帧。栈的增长和收缩由编译器插入的代码自动完成，随着函数的调用而分配，随函数的返回而自动释放。程序员无需关心，这一点与堆不同

### 堆

栈内存的分配需要实现确定其大小，而堆内存允许程序在运行时动态申请某个大小的内存空间。申请的内存在函数退出后仍然保留，需要手动释放。C语言中的`malloc/free`就是从堆中分配/释放内存，操作系统通过一个记录空闲内存地址的链表来管理堆内存

如果反复向操作系统申请内存而不释放，会导致内存泄露。在C/C++中，必须由程序员手动释放堆内存。而JAVA/Golang中有垃圾回收期，会定期主动回收内存。但是即使有垃圾回收器，也有内存泄露的分险，比如长期持有某个大对象的引用。

### 堆与栈的区别

1. 增长方向：栈向低地址方向增长，堆向高地址方向增长
2. 申请回收：栈自动分配和回收，堆需要手动申请和释放
3. 生命周期：栈的数据仅存在于函数运行过程中，堆的数据只要不释放就一直存在
4. 连续分配：栈是连续分配的，堆是不连续分配的，很容易产生内存碎片
5. 空间大小：栈的大小是有限的，而堆的空间较大，受限于系统中有效的虚拟内存

### 从堆和栈上建立对象哪个快

从两方面来考虑：
- 分配和释放，堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。
- 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。

## 缓冲区溢出
### 什么是缓冲区溢出

C语言使用运行时栈来存储过程信息，每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C对于数组引用不进行任何边界检查，因此**对越界的数组元素的写操作会破坏存储在栈中的状态信息**，这种现象称为缓冲区溢出。

![wt76gO](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/wt76gO.png)
### 缓冲区溢出的攻击方式

缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。

![6AKpOj](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/6AKpOj.png)

### 缓冲区溢出攻击的防范方法

#### 随机化

使用缓冲区溢出进行攻击，需要知道攻击代码的地址。因此常见的防范方法有：

1. 栈随机化：程序开始时在栈上分配一段随机大小的空间
2. 地址空间布局随机化（Address-Space Layout Randomization，ASLR）：每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域

但是攻击者依然可以使用蛮力克服随机化，这种方式称为“空操作雪橇（nop sled）”，即在实际的攻击代码前插入很长的一段 nop 指令序列，执行这条指令只会移动到下一条指令。因此只要攻击者能够猜中这段序列的某个地址，程序就会最终经过这段序列，到达攻击代码。

因此栈随机化和 ASLR 只能增加攻击一个系统的难度，**但不能完全保证安全**。

#### 栈保护

在发生缓冲区溢出、造成任何有害结果之前，尝试检测到它。常见的栈破坏检测方法是栈保护机制：在每个函数的栈帧的局部变量和栈状态之间存储一个**随机产生的**特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。

![GXNBsu](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/GXNBsu.png)

#### 限制可执行代码区域

内存页的访问形式有三种：可读、可写、可执行。只有编译器产生的那部分代码所处的内存才是可执行的，其他页应当限制为只允许读和写。以前 x86 将读和执行视为一个标志位，可读就可执行，为了限制某些页可读但不可执行，往往会带来严重的性能损失。现在新的处理器在硬件上引入新的位，将读和执行分开，由硬件来检查页是否可执行，效率上没有损失。
