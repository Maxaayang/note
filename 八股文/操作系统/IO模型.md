## I/O 模型
### 五种 I/O 模式

https://imageslr.com/2020/02/27/select-poll-epoll.html

阻塞 I/O、非阻塞 I/O、信号驱动式 I/O、I/O 多路复用、异步 I/O(aio)

**I/O 同步与异步的区别**：将数据从内核复制到用户空间时，用户进程是否会阻塞（需要用户进程来完成）
**I/O 阻塞与非阻塞的区别**：进程发起系统调用后，是会被挂起直到收到数据后再返回、还是立即返回成功或错误

![[Pasted image 20221109203537.png]]

### 阻塞 I/O 到 I/O 多路复用

**阻塞 I/O**：进程发起调用后，会被挂起，直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用多线程来处理多个文件描述符。
阻塞IO每个连接一个单独的线程进行处理，通常搭配多线程来进应对大流量，但是开辟多线程的开销比较大，一个程序可以开辟的线程是有限的，面对百万连接的情况，是无法处理的，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程轮询多个文件描述符是否就绪

阻塞等待的是内核数据准备好和数据从内核态拷贝到用户态的这两个过程

**非阻塞I/O**：非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果

最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓冲区的这个过程。

非阻塞IO解决了阻塞IO每个连接一个线程处理的问题，所以最大的优点是一个线程可以处理多个连接

**非阻塞 I/O 的缺点**：每次发起系统调用，只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。

因此引入了 **I/O 多路复用**，可以通过一次系统调用，检查多个文件描述符的状态。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

> I/O 多路复用相当于将遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪的过程从用户线程已到了内核中，由内核来负责轮询。

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：**如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回**。I/O 多路复用内部使用*非阻塞 I/O*检查每个描述符的就绪状态。

如果 `timeout` 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 `timeout` 参数设为 0，会立即返回，不阻塞。

I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。

**异步I/O**：内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。

### Linux 减少IO的方式有哪些

### aio的优缺点

### aio是半异步模式还是全异步模式

### 什么是文件描述符fd

文件描述符是一个非负整数，从0开始。进程使用文件描述符来标识一个打开的文件。

系统为每一个进程维护一个文件描述符表，表示该进程打开文件的记录表，而**文件描述符实际上就是这张表的索引**。当进程打开或者新建文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符--也就是新增表项的下标。

一般来说，每个进程最多可以打开64个文件。在不同的系统上，最多允许打开的文件个数不同，Linux2.4.22强制规定最多不能超过1048576

### fd_set 文件描述符集合

fd_set类型表示文件描述符的集合

由于文件描述符fd是一个从0开始的无符号整数，所以可以使用fd_set的二进制每一位来表示一个文件描述符。某一位为1，表示对应的文件描述符已就绪。


