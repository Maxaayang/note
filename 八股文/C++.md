
## 封装、继承、多态的理解

### 封装

封装的意义：
-   将属性和行为作为一个整体，表现生活中的事物
-   将属性和行为加以权限控制

**封装意义一：**
在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{ 访问权限： 属性 / 行为 };`

**封装意义二：**
类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：
1.  public 公共权限
2.  protected 保护权限
3.  private 私有权限

成员属性设为私有的优点：
**优点1**：将所有成员属性设置为私有，可以自己控制读写权限
**优点2**：对于写权限，我们可以检测数据的有效性

### 继承

父类中的私有成员也会被子类继承下去，只是被编译器隐藏之后访问不到了

继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

#### 有继承的类，new/delete构造和析构的顺序

### 多态

多态分为两类
-   静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
-   动态多态: 派生类和虚函数实现运行时多态（大多数）

静态多态和动态多态区别：
-   静态多态的函数地址早绑定 - 编译阶段确定函数地址
-   动态多态的函数地址晚绑定 - 运行阶段确定函数地址

多态满足条件
-   有继承关系
-   子类重写父类中的虚函数（函数返回值的类型、函数名、参数列表完全相同）

多态使用条件
-   父类指针或引用指向子类对象

多态的优点：
-   代码组织结构清晰
-   可读性强
-   利于前期和后期的扩展以及维护

多态：通过父类的指针或引用能够调用子类的函数，而非父类的函数
运行期多态：实现依赖于虚函数机制。当某个类声明了虚函数时，编译器为该对象分配一个虚函数指针，并为该类生成一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表去确定该虚函数的真正表现。

虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。
虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储指向虚表的指针

#### 为什么需要虚析构函数

如果指针的静态类型与被删除对象的动态类型不符，会出现内存泄露
例如静态类型为基类，而动态类型为派生类，这样在进行析构的时候如果不是虚析构函数，就不会调用派生类的析构函数，从而出现内存泄露。

https://blog.csdn.net/haoel/article/details/1948051
只有当一个类被用来作为基类时，才会把析构函数写做虚函数，因为当类里边有虚函数时，编译器会给类添加一个虚函数表，里面存放虚函数指针，这样会增加类的存储空间

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

https://blog.csdn.net/derkampf/article/details/62093252
1. 构造的时候是先调用父类的构造函数，再调用子类的构造函数
2. 父类的析构函数为虚函数，所以子类会在所有属性的前面形成虚表，而虚表内部存储的就是父类的虚函数
3. 当delete父类的指针时，由于子类的析构函数与父类的析构函数构成多态，所以得先调动子类的析构函数，再调动父类的析构函数，这是由delete所引起的，delete父类指针所指的空间，要调用父类的析构函数

- 当父类的析构函数不声明成虚析构函数时，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数
- 当父类的析构函数声明成虚析构函数时，当子类继承父类，父类的指针指向子类时，delete掉父类的指针。先调动子类的析构函数，再调动父类的析构函数

编译器会隐式的执行派生类到基类的转换
```C++
Quote item;        // 基类对象
Bulk_quote bulk;   // 派生类对象
Quote *p = &item;  // p指向Quote对象
p = &bulk;         // p指向bulk的Quote对象
Quote &r = bulk;   // r绑定到bulk的Quote部分
```

动态绑定只有当通过指针或引用调用虚函数时才会发生

### 虚函数怎么起作用


### 虚函数表对 class 大小有影响吗

### 虚函数的开销


## static的用法和作用
https://www.leftpocket.cn/post/cpp/static/
https://blog.csdn.net/ypshowm/article/details/89030194


## 静态变量与全局变量的区别


## 左值与右值

左值(lvalue)、将亡值(xvalue)、纯右值(prvalue)、泛左值(gvalue)、右值(rvalue)

特征：
- 具名：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们锁标识的对象或函数(直接或间接获得)的地址
- 可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式

### 左值

左值具有以下特征：
-   可通过取地址运算符获取其地址
-   可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数
-   可以用来初始化左值引用(后面有讲)

### 纯右值

字面值或函数返回的非引用都是纯右值

特征：
- 不会是多态
- 不会是抽象类型或数组
- 不会是不完全类型

### 将亡值

通过"盗取"其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过"盗取"的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

具名的临时值、同时又能被move

xvalue 只能通过两种方式来获得，这两种方式都涉及到将一个左值赋给(转化为)一个右值引用：
-   返回右值引用的函数的调用表达式,如 `static_cast<T&&>(t);` 该表达式得到一个 xvalue
-   转换为右值引用的转换函数的调用表达式，如：std::move(t)、satic_cast<T&&>(t)

### 泛左值

特征：
-   可以自动转换成prvalue
-   可以是多态的
-   可以是不完整类型，如前置声明但未定义的类类型

### 右值

特征：
-   无法对rvalue进行取地址操作。例如：`&1`，`&(a + b)`，这些表达式没有意义，也编译不过。
-   rvalue不能放在赋值或者组合赋值符号的左边，例如：`3 = 5`，`3 += 5`，这些表达式没有意义，也编译不过。
-   rvalue可以用来初始化const左值引用（见下文）。例如：`const int& a = 1`。
-   rvalue可以用来初始化右值引用（见下文）。
-   rvalue可以影响函数重载：当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。

### 什么时候用到右值

## 移动构造函数/移动赋值运算符函数的流程


## move 与 forward 的区别

https://zhuanlan.zhihu.com/p/55856487
https://www.cnblogs.com/xiaoshiwang/p/9589008.html

## new 可以重载吗

new不可以，但是 operator new 可以

### new的过程

- new 调用operator new的标准函数，该函数分配一个足够大的、原始的、未命名的内存空间以便存储特定类型的对象
- 编译器运行相应的构造函数以构造这些对象，并为其传入初始值
- 对象被分配了空间并构造完成，返回一个指向该对象的指针

### delete的过程

- 对指针指向的对象或者所指向的数组中的元素执行对应的析构函数
- 编译器调用operator delete的标准库函数释放内存空间

## C和C++内存分配的区别

## C/C++ 内存组成

堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区

![[Pasted image 20221107091029.png]]
- **栈**：在执行函数的时候，函数内局部变量的存储单元都可以在栈上创建、函数执行结束时这些存储单元自动被释放。栈内存分配运算内置与处理器的指令之中，效率很高，但是分配的内存容量有限
- **堆**：由 new 分配的内存块，他们的释放编译器不管，由我们的应用程序去控制，一般一个 new 就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收
- **自由存储区**：若堆是操作系统维护的一块内存，那么自由存储区就是C++中通过 new 和 delete 动态分配和释放对象的抽象概念。自由存储区和堆是比较像的，但他们不等价
- **全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量个静态变量又分为初始化和未初始化的，在C++里面没有这个区分了。他们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始化为0。在程序编译的时候就已经分配好了，这块内存在程序的整个运行期间都存在，主要存放静态数据（局部static变量、全局static变量）、全局变量和常量。
- **常量存储区**：这是一块比较特殊的存储区，这里面通常存放的是常量，不允许修改
- **代码区**：存放函数体的二进制代码

## 自由内存和堆的区别

https://www.cnblogs.com/QG-whz/p/5060894.html
- 自由存储是C++中通过new与delete动态分配和释放对象的**抽象概念**，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
- 堆与自由存储区还是有区别的，它们并非等价。

## 内存泄露
### 怎么会造成内存泄露

内存泄露是由于疏忽或错误造成了程序未能释放掉不使用的内存的情况。内存泄露并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制。

### 如何检测内存泄露

### 内存泄露与内存溢出有什么区别

## 构造与析构的作用

- 构造函数：初始化类对象的数据成员，不能被声明成const
- 析构函数：释放对象使用的资源，并销毁对象的非static数据成员
	- 析构的顺序是按初始化顺序的逆序
	- 隐式销毁一个内置指针的成员不会delete它所指向的对象
	- 析构函数体本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的


## 为什么拷贝构造函数的参数必须是引用

如果不是引用的话，就会永远不成功，因为为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝它的实参，有需要调用拷贝构造函数，即出现了无限循环

## 多态虚函数的不同形式




## new 和 malloc 的区别

https://www.codenong.com/cs105390789/

对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器的控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete

- 属性
	- new/delete 是 C++ 关键字，需要编译器支持。malloc/free 是库函数，需要头文件支持
- 参数
	- 使用 new 操作符申请内存分配时无需指定内存块的大小，编译器会根据类型信息自行计算。而 malloc 则需要显式地指出所需内存的尺寸
- 返回类型
	- new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故 new 是符合安全性的操作符。
	- malloc 内存分配成功则是返回 void* (可强制转换为任何类型)，需要通过强制类型转换将 void* 指针转换为我们需要的类型
- 分配失败
	- new 内存分配失败时，会抛出 bac_alloc 异常
	- malloc 内存分配失败时返回 NULL
- 自定义类型
	- new 会先调用 operator new 函数，申请足够的内存（通常底层使用 malloc 实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用 operator delete 函数释放内存（通常底层使用 free 实现）
	- malloc/free 是库函数，只能动态申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作
- 重载
	- C++ 允许重载 new/delete 操作符，特别的，布局 new 的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new 在这段内存上为对象都不用构造函数完成初始化工作，并返回此地址
	- malloc 不允许重载
- 内存区域
	- new 操作符从[[C++#自由内存和堆的区别|自由存储区]]上为对象动态分配内存空间，自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区
	- malloc 函数从堆上动态分配内存，堆是操作系统的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用 malloc 从堆上分配内存，使用 free 释放已分配的对应内存


为什么不使用 mmap 和 munmap创建和删除虚拟内存的区域？
使用动态内存分配器有更方便，也有更好的可移植性

ptr 必须指向一个从 malloc、calloc 或者 realloc 获得的已分配块的起始位置，若不是，那么 free 的行为就是未定义的

### malloc内存分配的过程

https://imageslr.com/2020/malloc.html

[[动态内存分配]]

### malloc 与 free 的原理

- 在标准 C 库中，提供了malloc/free函数分配和释放内存，这两个函数底层是由brk、mmap、munmap这些系统调用实现的
- brk是将数据段 (.data) 的最高地址指针 \_edata 往高地址推，mmap是在进程的虚拟地址空间中(堆和栈中间，称为映射区域的地方)找一块空闲的虚拟地址。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间时，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系
- malloc小于128k的内存，使用brk分配内存，将 \_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128k时，执行内存紧缩。在上一个步骤free的时候，发现最高地址空闲内存超过128k，于是内存紧缩
- malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历链表，然后找到第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序

### free 释放内存，会归还给操作系统吗

- malloc 通过 brk() 方式申请内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
- malloc() 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放

### 为什么不全使用mmap分配内存

- 向操作系统申请内存，是要通过系统调用的，需要进入内核态再回到用户态，运行态切换耗时
- mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候，就会触发缺页中断
- brk 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次再申请内存的时候，就直接从内存池取出对应的内存块就行，而且可能这个内存块的虚拟地址与物理地址的映射关系还在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低CPU的消耗

### 为什么不全用 brk

会导致堆内产生内存碎片，大量碎片导致内存泄露

### 内存池链表太长怎么办

二级空间配置器

对于链表的并发访问除了加锁还可以怎么办（原子操作？）


## 动态链接和静态链接的区别

### 静态链接

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把他们和应用程序的其他模块组合起来创建最终的可执行文件。

**空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在内存存在多个副本的情况。

**更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序

**运行速度快**：在可执行程序中已经具备了所有可执行程序所需要的任何东西，在执行的时候运行速度快。

### 动态链接

把程序按照模块拆分成各个相对独立部分。在程序运行时才将他们链接在一起形成一个完整的程序，而不是像静态链接那样把所有模块都链接成一个单独的可执行文件

**共享库**：即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本

**更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序在重新链接一遍、当程序下一次运行时。新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

**性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定的损失。

### 动态库 .so 和静态库 .o 的区别


### 怎么查看使用到的动态链接库


### 多个进程用动态库会有多份拷贝吗











## STL

### STL 里的queue是线程安全的吗

### map与unordered_map的底层实现


### map 与 unordered_map 的区别

### vector是怎么动态扩容的
扩容一定是2倍吗？

### vector 与 list 的区别

- vector底层是一个连续的空间，list底层的空间是离散的，每一个元素都是单独的一个空间
- 在插入与删除之后，list都不会导致原来的迭代器的失效，而vector可能因为空间的重新配置而导致迭代器的失效
### vector与list的适用场景

### 散列表怎么进行扩容

### 双向链表的实现

### push_back和emplace_back的区别

## C++ struct 和 class 的区别


## C语言中的struct是如何使用的，与C++中有什么区别


## lambda
### 针对 lambda 捕获变量，怎么保证他是有效的

### lambda的捕获方式

### lambda入户捕获unique_ptr

引用捕获，因为unique_ptr没有拷贝构造

### lambda捕获unique_ptr后如何避免调用lambda时unique_ptr的指针已失效

使用移动捕获(C++ 14/17 的特性)

### lambda如何捕获shared_ptr

值捕获，避免调用时shared_ptr对象已销毁

### lambda捕获shared_ptr时如果不想延长对象生命周期怎么做

先赋值给weak_ptr，再捕获


## 智能指针
### unique_ptr
#### 如何实现独占所有权的


#### 怎么转移所有权


### shared_ptr
#### 怎么实现共享所有权


#### 引用计数和管理的内存地址怎么实现的？是同一块内存空间吗


#### shared_ptr 的 b = a 怎么实现


#### b = move(a) 怎么实现


#### 如何保证资源是有效的

引用计数

#### 如何控制引用计数

### weak_ptr
#### weak_PTR 的应用场景

## 对象调用父类函数的过程


## 网络编程
### socket write 满了怎么样


### select/epoll怎么用


### socket流程




### ET 与 LT 的区别


### ET 与 LT 哪个性能更好？


### select 和 epoll 的区别


#### 什么时候使用 select


#### epoll 相比于 select 的优势


### epoll底层实现

### I/O 多路复用及其原理


### 网络 IO 发展历程

从阻塞IO到reactor模型

## 如何查看编译后的可执行文件

objdump


## 指针与引用的区别

## volatile关键字的作用以及原理

## static 关键字的作用

## 程序执行的四个过程


## 如何利用vector实现基于堆结构的定时器




## 原子性是什么，i++ 是原子的吗


## 为什么要有内存对齐，怎么实现

