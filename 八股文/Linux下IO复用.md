https://mp.weixin.qq.com/s/5xj42JPKG8o5T7hjXIKywg
https://www.yuque.com/tuobaaxiu/inyebp/tk3ywg
https://mp.weixin.qq.com/s/9vVs2olnfoVEpoJCFWUmMQ

基本原理是select、poll、epoll 不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程

特点是通过一种机制一个进程能够同时等待多个文件描述符，而这些文件描述度其中的任意一个进入读就绪状态，就能够通知程序进行相应的读写操作

## select、poll、epoll

这几个都是IO多路复用机制，IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一但某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。但select、poll、epoll本质上都是同步IO，因为它们都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。

### select

**select的执行过程**
如果服务器进程A启动时要监听多个连接的socket文件描述符，如果这几个连接的数据都没有到达网卡，那么进程A就会让出CPU，进入阻塞状态，同时会将进程A的进程描述符和被唤醒时用到的回调函数组成等待队列项加入到socket对象的进程的等待队列中

当网卡接收到数据，然后网卡通过中断信号通知CPU有数据到达，执行中断程序，中断程序主要做了两件事：
- 将网络数据写入对应socket的数据接收队列里面
- 唤醒队列中的等待进程A，重新将进程A放入CPU的运行队列

缺点：
- 性能开销大
	- 调用select时会陷入内核，这时需要将参数中的 fd_set 从用户空间拷贝到内核空间，select执行完后，还需要将 fd_set 从内核空间拷贝回用户空间，高并发场景下这样的拷贝会消耗极大资源 (epoll 优化了不拷贝) 
	- 进程被唤醒后，不知道哪些连接已就绪即收到了数据，需要遍历传递进来的所有 fd_set 的每一位，不管它们是否就绪 (epoll 优化为异步事件通知)
	- select 只返回就绪文件的个数，具体哪个文件可读还需要遍历 (epoll 优化为只返回就绪文件描述符，无需做无效的遍历)
	- fd_set 不可重用，新的 fd 进来，需要重新创建
- 同时能够监听的文件描述符数量太少，受限于 sizeof(fd_set) 的大小，在编译内核时就确定了且无法更改，一般是32位操作系统是1024，64位操作系统是2048 (poll、epoll 优化为使用链表的方式)

### poll

与select类似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而非 select 的 fd_set 结构。

管理多个描述符也是进行轮询，根据描述符的状态进行处理， 但poll无最大文件描述符数量的限制，因其基于链表存储

select 和 poll 在内部机制方面没有太大的差异，相比于 select 机制，poll 只是取消了最大监控文件描述符数限制，并且不需要重新创建 fd_set，并没有从根本上解决 select 存在的问题。

缺点：
- 每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大
- 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低

### epoll

epoll是Linux特有的IO复用函数，它在实现和使用上与select和poll有很大差异，首先，epoll使用一组函数来完成操作，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核上的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集合事件表。但epoll需要使用一个额外的文件描述符，来唯一标识内核中这个事件表

解决了性能开销大和文件描述符数量少的缺点，是性能最高的多路复用实现方式，能支持的并发量也是最大的

- 使用红黑树存储一份文件描述符集合，每个文件描述符只需在添加时传入一次，无需用户每次都重新传入，解决了select 中 fd_set 重复拷贝到内核的问题
- 通过异步IO事件找到就绪的文件描述符，而不是通过轮询的方式
- 使用队列存储就绪的文件描述符，且会按需返回就绪的文件描述符，无需再次遍历
- 不同于select 和 poll 轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数

### 两种触发模式

- LT：水平触发
	- 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程，是默认的一种模式，并且同时支持 Blocking 和 No-Blocking

- ET：边缘触发
	- 通知后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比LT模式高，只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死

### epoll 数据结构

epoll在添加一个 socket 或者删除一个 socket 或者修改一个 socket 的时候，它需要查询速度更快，操作效率最高，因此需要一个更加优秀的数据结构能够管理这些 socket。

因为处理上万级的 fd，他们本身的存储空间不会很大，所以倾向于在内存中去实现管理，而红黑树是一种非常优秀的平衡树，它完全是在内存中操作，而且查找，删除和新增的时间复杂度都是 logn，效率非常高，因此选择用红黑树实现 epoll 是最佳的选择。