
## 事务的特性

- 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像从来没有执行过一样
- 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
- 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
- 持久性：事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。

## InnoDB如何保证事务的四个特性

- 持久性：redo log
	- redo log 由两部分组成，一是内存中的重做日志缓冲区，另一个是在磁盘上的重做日志文件
	- 在之前的操作中，修改数据是先把数据加载到内存中，然后在事务提交的时候再写回到磁盘上，但是有可能只修改一个页里面的一个字节，这样就比较浪费资源，或者可能牵涉到多个页的修改，并且这些页是不相邻的，属于随机IO，速度就比较慢
	- 使用 redo log进行刷盘效率就比较高、首先是它的体积比较小，此外因为是一直往末尾进行追加，属于顺序IO，所以效率比较高
- 原子性：undo log
	- undo log 不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉
- 隔离性：MVCC、锁
- 一致性：持久性 + 原子性 + 隔离性
	- 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性
	- 从应用层面，通过代码判断数据库是否有效，然后决定回滚还是提交数据

## 并发事务会引发什么
### 脏读

脏读：一个事务读到了另一个未提交事务修还过的数据

### 不可重复读

不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就发生了不可重复读的现象

### 幻读

在一个事务内叠词查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象

**不可重复读的重点是修改，幻读的重点在于新增或者删除**

## 如何解决并发问题

- 在web服务框架中加入缓存。在服务器与数据库层之间加入缓冲层，将高频访问的数据存入缓存中，减少数据库的读取负担
- 增加数据库索引，进而提高查询速度，不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢
- 主从分离，让主服务器负责写，从服务器负责读
- 将数据库进行拆分，使得数据库的表尽可能小，提高查询速度
- 使用分布式框架，分散计算压力

## 事务隔离级别

SQL有四种隔离级别，隔离级别越高，性能越低

- 读未提交：指一个事务还没提交时，它做的变更就能被其他事务看到
- 读提交：指一个事务提交之后，它做的变更才能被其他事务看到，只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以在多次使用查询语句时，可能得到不同的结果
- 可重复度：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**
- 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行


不同隔离级别可能出现的现象：

![QYVC0N](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/QYVC0N.png)



**如何实现这四种隔离级别**

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。

## Read View 在 MVCC 里如何工作

Read View 有四个重要字段：

- m_ids：指的是在创建 Read View 时，当前数据库中的「活跃事务」的事务 id 列表，活跃事务指的是启动了但还没有提交的事务
- min_trx_id：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值
- max_trx_id：创建 Read View 时当前数据库应该给下一个事务的 id 值，也就是全局事务中最大事务 id 值 + 1，并不是 m_ids 的最大值
- creator_trx_id：创建该 Read View 的事务的事务 id


聚簇索引记录中包含的两个隐藏列：

- trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里
- roll_pointer：每次对每条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向一个旧版本记录，于是就可以通过它找到修改前的记录

![YY6C5i](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/YY6C5i.png)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有以下情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**

## 可重复读是如何工作的

可重复读隔离级别是启动事务是生成一个 Read View，然后整个事务期间都在用这个 Read View

每次读取数据的时候，都要查看对应记录的trx_id

- 如果比当前事务中的 min_trx_id 还小的话，就意味着修改这条记录的事务在当前事务启动前就已经提交过了，所以是可见的
- 如果位于当前事务的 Read View 的 min_trx_id 与 max_trx_id 之间，则需要判断 trx_id 是否在 m_ids 范围内，如果在的话，那这条记录就是被还未提交的事务修改的，就不会读取这个版本的记录，而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 小于当前事务的 Read View 中的 min_trx_id 的第一条记录
- 如果其他事务在当前事务期间提交了，因为当前事务还是基于事务启动时创建的 Read View 来判断当前版本的记录是否可见的，所以读到的还是事务启动前的记录 

## 读提交是如何工作的

读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View，这就意味着事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为这期间另外一个事务修改了该记录，并提交了事务

> 为什么读不到其他还未提交的事务修改的数据？
>
> 事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明**这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录**。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。
>
> 我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？
>
> 在事务 A 提交后，**由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View**，此时事务 B 第三次读取数据时创建的 Read View 如下：
>
> ![CXMaU7](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/CXMaU7.png)
>
> 事务 B 在找到小林这条记录时，**会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的**。
>
> 正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

## MySQL可重复读隔离级别，完全解决了幻读吗？

MySQL在可重复读的情况下，可以很大程度避免幻读，但是**并不是可以彻底避免**

解决方案：
- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
  - 事务开始后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链中找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，也是查询不到这条数据的，所以就很好的避免了幻读的问题
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。



> 幻读发生的场景
>
> 1. 事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。然后事务 B 插入一条 id = 5 的记录，并且提交了事务。此时，**事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景**。在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。
> 2. T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
>
> **要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句**，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。

## MySQL为什么要有事务回滚机制

在MySQL中，恢复机制是通过回滚日志实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后对数据库中的对应行进行写入。当事务已经被提交之后，就无法再次回滚了

回滚日志的作用：
- 能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息
- 在整个系统发生崩溃、数据库进程直接被杀死之后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后先数据库的主要原因




