InnoDB会把存储的数据划分成若干个页，以页作为磁盘和内存交互的基本单位，一个页的默认大小为16KB。因此，Buffer Poll 同样需要按页来划分

在MySQL启动的时候，InnoDB会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 16KB 的大小划分出一个个的页，Buffer Pool 中的页就叫做缓存页。此时这些缓存页是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。

Buffer Pool 除了缓存页和数据页、还包括 undo 页，插入缓存、自适应哈希索引、锁信息等

为了更好的管理缓存在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个控制块，控制信息包括缓存页的表空间、页号、缓存页地址、链表节点等等。

Free链表：为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的控制块作为链表的节点

Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息

Free链表的节点是一个一个的控制块，每个控制块包含着对应缓存页的地址，所以相当于Free链表节点都对应着一个空闲的缓存页

为了加速脏页的刷盘，Buffer Pool 专门维护了一个 flush链表，其中的节点也是控制块，但是链表的节点都是脏页

## 如何提高缓存的命中率

简单的LRU无法避免两个问题
- 预读失效
- Buffer Pool 污染

### 预读失效

提前被加载进来的页并没有被访问到，如果使用简单的LRU算法，就会把预读页放到LRU链表的头部，而当 Buffer Pool 空间不够的时候，还需要把末尾的页淘汰掉，如果这些预读页一直不会被访问到，那么就会大大降低缓存命中率

MySQL将LRU算法划分为了两个区域：old区域和young区域

预读的页只需要加入到old区域的头部，当页被真正访问的时候，才将页插入young区域的头部，如果预读的页一直没有被访问到，就会从old区域移除，这样就不会影响 young 区域中的热点数据

### Buffer Pool 污染

Buffer Pool污染：某一个SQL语句扫描了大量的数据，在Buffer Pool空间比较有限的情况下，可能会将Buffer Pool里的所有页都替换出去，导致大量的热数据被淘汰了，等这些数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘IO，MySQL性能几急剧下降

解决方案
- 在进入到young区域的条件增加一个停留在old 区域的时间判断
	- 在某个处在old区域烦人缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问的时间
	- 如果后续的访问时间与第一次访问时间在某个时间间隔内，那么该缓存页就不会被old区域移动到young区域的头部
	- 如果后续的访问时间与第一次访问时间不在某个时间间隔内，那么该缓存页移动到young的头部

### 脏页什么时候被刷入磁盘

- 当 redo log 日志满了的时候，会主动触发脏页刷新到磁盘
- Buffer Pool 空间不足时，需要将一部分数据页淘汰掉的时候，如果淘汰的是脏页，需要先将脏页同步到磁盘
- MySQL空闲时，后台线程会定期将适量的脏页刷入到磁盘
- MySQL正常关闭之前，会把所有的脏页刷入到磁盘








