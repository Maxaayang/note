## 为什么使用索引

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## MySQL中有哪些索引，有什么特点

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一(可以有NULL)
- 主键索引：加速查询 + 列值唯一(不可以有NULL) + 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索
- 索引合并：使用多个单列索引组合搜索
- 索引覆盖：select的数据列只用从索引中就能取的，不必读取数据行，即查询列要被所建的索引覆盖
- 聚簇索引：表数据是和主键一起存储的，主键索引的叶节点存储行数据(包含了主键值)，二级索引的叶节点存储行的主键值。使用的是B+Tree作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址，叶子节点上的数据是主键与具体记录

## 索引的分类

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引
- 按「物理存储」分类：聚簇索引(主键索引)、二级索引(辅助索引)
- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引
- 按「字段个数」分类：单列索引、联合索引

### 按数据结构分类

![U68qF2](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/U68qF2.png)

在创建表时，InnoDB存储引擎会根据不同的场景选择不同的列作为索引
- 如果有主键，默认会使用主键作为聚簇索引的索引键
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键
- 在上面两个都没有的情况下，InnoDB将会自动生成一个隐式自增id列作为聚簇索引的索引键

创建的主键索引和二级索引默认使用的是B+tree索引

**B+Tree相比于B树和二叉树最大的优势是，查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次**

主键索引的B+Tree和二级索引的B+Tree区别：
- 主键索引的B+Tree的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+Tree的叶子节点里
- 二级索引的B+Tree的叶子节点存放的是主键值，而不是实际数据

**回表**：先从二级索引中的B+Tree的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的B+Tree树查询到对应的叶子节点，然后获取整行数据

**覆盖索引**：在二级索引的B+Tree就能查询到结果的过程
- 由于辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作

### 按物理存储分类

从物理存储的角度来看，索引分为聚簇索引(主键索引)、二级索引(辅助索引)

### 按字段特性分类

主键索引、唯一索引、普通索引、前缀索引

- 主键索引：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值
- 唯一索引：建立在unique字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值
- 普通索引：建立在普通字段上的索引，既不要求字段为主键，也不要求UNIQUE
- 前缀索引：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binary、varbinary的列上
  - 使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率

### 按字段个数分类

单列索引、联合索引

使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配，因为其他的元素是全局无序，局部有序的

联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配

索引下推：在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的判断，减少回表次数

索引区分度：建立联合索引的字段顺序，对索引效率的印象很大，越靠前的字段被用于索引过滤的概率越大。
如果索引的区分度很小，MySQL一般会忽略索引，进行全表扫描

联合索引进行排序

**联合索引的优势是减少结果集数量**

## 聚簇索引非聚簇索引
### 聚簇索引

**聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。**

在 MySQL 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

聚簇索引和非聚簇索引的根本区别是表记录的排列顺序与索引的顺序是否一致

优点：
- **查询速度非常快** ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。
- **对排序查找和范围查找优化** ：聚簇索引对于主键的排序查找和范围查找速度非常快。

缺点：
- **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的

### 非聚簇索引

**非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引**

非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

优点：更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的

缺点：
- **依赖于有序的数据** ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据
- **可能会二次查询(回表)** ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

## 为什么要使用联合索引

联合索引：使用表中的多个字段创建的索引

- **减少开销**。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！

- **覆盖索引**。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。

最左前缀匹配原则：在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。

所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## 索引下推

在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数

## 索引的优缺点、特点

索引的特点：
- 可以加快数据库的检索速度
- 降低数据库插入、修改、删除等维护的速度
- 只能创建在表上，不能创建在视图上
- 既可以直接创建也可以间接创建

索引的优点：
- 大大加快了数据的检索速度
- 可以显著减少查询中分组和排序的时间
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
- 将随机IO变为顺序IO

索引的缺点：
- 需要占用物理空间，数量越大，占用的空间越大
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大
- 会降低表的增删改的效率，因为每次增删改索引，B+树为了维护索引，都需要进行动态维护

## 什么时候需要 / 不需要索引

什么时候使用索引
- 字段有唯一限制性
- 经常用于`WHERE`查询条件的字段，这样能够提高整个表的查询速度，如果查询疑难件不是一个字段，可以建立联合索引
- 经常用于`GROUP BY`和`ORDER BY`的字段，这样在查询的时候就不需要再去做一次排序了，因为建立索引之后在B+Tree中的记录都是排好序的

什么时候不需要索引
- `WHERE`条件，`GROUP BY`，`ORDER BY`里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的
- 字段中存在大量重复数据，不需要创建索引，因为MySQL里有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描
- 表数据太少的时候，不需要建立索引
- 经常更新的字段不用创建索引，因为索引字段频繁修改，由于要维护B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的

## 索引的适用场景

- 匹配全值
	- 对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件
- 匹配值的范围查询
	- 对索引的值能够进行范围查询
- 匹配最左前缀
	- 仅仅使用索引中的最左边的列进行查询
- 仅仅对索引进行查询
	- 当查询的列都在索引的字段中时，查询的效率更高
- 匹配列前缀
	- 仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找
- 能够实现索引匹配部分精确而其他部分进行范围匹配
- 经常出现在关键字 order vy、group by、distinct 后面的字段
- 在union等集合操作的结果集字段
- 考虑使用索引覆盖，对数据很少被更新，如果用户经常值查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描变为索引的扫描

## 如何优化索引
### 前缀索引优化

使用前缀索引是为了减小索引字段的大小，可以增加一个索引页中存储的索引量，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助减小索引项的大小

缺点：
- order by 无法使用前缀索引
- 无法把前缀索引作覆盖索引

### 覆盖索引优化

建立一个联合索引，如果索引中存在需要的数据，查询将不会再次检索主键索引，从而避免回表

覆盖索引的好处：不需要查询除包含整行记录的所有信息，也就减少了大量的IO操作

### Multi-Range Read 优化

这种优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这种优化适用于range、ref、eq_ref 类型的查询

好处：
- 让数据访问变得较为顺序
- 减少缓冲区中页被替换的次数
- 批量处理对键值的查询操作

### Index Condition Pushdown(ICP) 优化

不支持这种方式之前，当进行索引查询时，首先我们先根据索引查找记录，然后再根据where条件来过滤记录。然而，当支持ICP优化后，MySQL数据库会在取出索引的同时，判断是否可以进行where条件过滤，也就是将where过滤部分放在了存储引擎层，大大减少了上层SQL对记录的索取。

ICP支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。

## 为什么InnoDB选择B+Tree作为索引的数据结构

主要原因是因为B+Tree只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B 树只能中序遍历所有节点，效率太低

Hash
- 利用Hash需要把数据全部**加载到内存中**，如果数据量大，是一件很**消耗内存**的事，而采用B+树，是基于**按照节点分段加载，由此减少内存消耗**。
- 和业务场景有段，**对于唯一查找**（查找一个值），Hash确实更快，**但数据库中经常查询多条数据**，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。
- b+树的**非叶子节点不保存数据**，**只保存子树的临界值**（最大或者最小），所以同样大小的节点，**b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**。

用B+Tree是为了减少IO次数

- 不可能把索引全部加载到内存中，只能逐一加载每个索引节点
- B+Tree的单个节点中包含的值个数越多，那么节点总数就会越少，IO次数也越少
- B+Tree高度一般为2-4层，查找记录时最多只需要2-4次IO

- B+Tree 与 B Tree
	- B+Tree只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以B+Tree的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点
	- B+Tree叶子节点才用的是双向链表，适合MySQL中常见的基于范围的顺序查找，而B 树无法做到这一点
- B+Tree 与二叉树
	- 对于有N个叶子节点的B+Tree，其搜索复杂度为 `O(logdN)`，其中d表示节点允许的最大子节点个数为d个。在实际的应用当中，d是大于100的，这就保证了即使数据达到千万级别，B+Tree的高度依然维持在3-4层左右，也就是说一次数据查询操作只需要做3-4次的磁盘 I/O 操作就能查询到目标数据
	- 二叉树的每个父节点的儿子节点个数只能是2个，意味着其搜索复杂度为 `O(logN)`，这已经比B+Tree高出了不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数更多
- B+Tree 与 Hash
	- Hash 在做等值查询的时候，搜索复杂度为 `O(1)`，但是Hash表不适合做范围查询，所以B+Tree索引比Hash表索引有着更广泛的适用场景

## MyISAM 与InnoDB实现B 树索引的区别

- MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”

- InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。

在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

## 文件索引和数据库索引为什么使用B+Tree

文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。

最重要的是，B+树还有一个最大的好处：方便扫库。

B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。

B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。

B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

## 为什么B+Tree比B 树更适合实际应用中的操作系统的文件索引和数据库索引

B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定

数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

**B+树的特点**
- 所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;
- 不可能在非叶子结点命中;
- 非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;

## MySQL索引主要使用的两种数据结构

- 哈希索引，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在绝大多数需求为单条记录查询 的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引

- **BTree索引**，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。

但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

## 为什么MySQL索引使用B+树，而不是B树、红黑树、Hash表

**B+Tree与Hash的对比**

- 利用Hash需要把数据全部**加载到内存中**，如果数据量大，是一件很**消耗内存**的事，而采用B+树，是基于**按照节点分段加载，由此减少内存消耗**。
- 和业务场景有段，**对于唯一查找**（查找一个值），Hash确实更快，**但数据库中经常查询多条数据**，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。
- b+树的**非叶子节点不保存数据**，**只保存子树的临界值**（最大或者最小），所以同样大小的节点，**b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**。

## MySQL的四种索引类型

- **FULLTEXT** ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。
- **HASH** ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- **BTREE** ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
- **RTREE** ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。

## 索引使用的注意事项

- 不要在列上使用函数或者进行运算，这将导致索引失效而进行全表扫描
- 尽量避免使用 != 或 not in 或 <> 等否定操作符
	- 因为这几个操作符都会导致索引失效而进行全表扫描。
	- 尽量避免使用 or 来连接条件，应该尽量避免在 where 子句中使用 or 连接条件，因为这会导致索引失效而进行全表扫描
- 多个单列索引并不是最佳选择
	- MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高MySQL的查询性能
- 复合索引的最左前缀原则
	- 在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引
- 覆盖索引的好处
	- 如果一个索引包含所需查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的
- 范围查询对多列查询的影响
	- 查询中的某个列有范围查询，则其右边的所有列都无法使用索引优化查找
- 索引不会包含有NULL值的列
	 - 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要一列含有NULL值，那么这一列对于此复合索引就是无效的。因此在数据库设计时，除非有一个很特别的原因使用NULL值，不然尽量不要让字段的默认值为NULL
- 隐式转换的影响
	 - 当查询条件左右两侧类型不匹配的时候就会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描
- like 语句的索引失效问题
	 - like 的方式进行查询，在 like "value%" 可以使用索引，但是对于 like "%value%" 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情

## 为什么不对表的每一列都建一个索引

- 当对表中的数据进行增加、删除和修改的时候，**索引也要动态的维护**，这样就降低了数据的维护速度。
- **索引需要占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。
- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加

## 创建索引是需要注意的点
### 主键索引尽量是自增的

InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

**如果我们使用自增主键**，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。

**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小(二级索引的叶子节点存放的数据是主键值)，这样二级索引占用的空间也就越小

### 索引最好设置为 NOT NULL

- 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为NULL的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count会省略值为NULL的行
- NULL是一个没有意义的值，但是它会占用物理空间，所以会带来存储空间的问题，因为InnoDB存储记录的时候，如果表中存在允许为NULL的字段，那么行格式中至少会占用1字节空间存储NULL值列表

![CAWVWc](https://cdn.jsdelivr.net/gh/Maxaayang/pic@main/uPic/CAWVWc.jpg)

### 防止索引失效

发生索引失效的情况
- 当使用左或者左右模糊匹配的时候会造成索引失效
- 当在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引匹配，否则就会导致所以失效
- 在WHERE子句中，如果在OR条件前的条件列是索引列，而在OR后的条件列不是索引列，那么索引会失效

### 索引字段越小越好

数据库的存储以页为单位，一页存储的数据越多，一次IO操作获取的数据越大，效率越高。唯一、不为空、经常被查询的字段适合做索引

### 尽可能建立联合索引而不是单列索引

因为索引需要占用磁盘空间，可以简单理解为每个索引都对应着一颗B+Tree。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引中庸的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大的磁盘空间，且修改数据的操作效率也会提升

## 索引碎片
### 外部碎片

当索引页不在逻辑顺序上时就会产生外部碎片。索引创建时，索引键按照逻辑顺序放在一组索引页上。当新数据插入索引时，新的键可能放在存在的键之间。为了让新的键按照正确的顺序插入，可能会创建新的索引页来存储需要移动的那些存在的键。这些新的索引页通常物理上不会和那些被移动的键原来所在的页相邻。创建新页的过程会引起索引页偏离逻辑顺序。

### 内部碎片

当索引页没有用到最大量时就产生了内部碎片。虽然在一个有频繁数据插入的应用程序里这也许有帮助，然而设置一个fill factor（填充因子）会在索引页上留下空间，服务器内部碎片会导致索引尺寸增加，从而在返回需要的数据时要执行额外的读操作。这些额外的读操作会降低查询的性能。

### 解决方案

- 删除并重建索引
- 使用DROP_EXISTING 子句重建索引
- 执行 DBCC DBREINDEX
- 执行 DBCC INDEXDEFRAG
