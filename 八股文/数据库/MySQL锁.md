## 全局锁

主要用在全库的逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现文件的数据与预期的不一样

缺点：加上全局锁，整个数据库都处于了只读的状态

如何避免全局锁对业务的影响？
如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在数据库备份之前先开启事务，会先创建Read View，然后整个事务执行期间都在用Read View，而且由于MVCC的支持，备份期间业务依然可以对数据进行更新操作

## 表级锁

- 表锁
- 元数据锁(MDL)
- 意向锁
- AUTO-INC锁

### 表锁

表锁包括共享锁和独占锁，即读写锁
表锁除了会限制别的线程的读写之外，也会限制本线程接下来的读写操作

表锁不会出现死锁，发生冲突的几率高，并发低

MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给设计的表加写锁，所以不适合做写为主表的引擎。写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞

### 元数据锁

不需要显式的使用MDL，因为当对数据库表进行操作时，会自动给这个表加上MDL
- 对一张表进行CRUD操作时，加的是MDL读锁
- 对一张表做结构变更操作的时候，加的是MDL写锁

MDL是在事务提交后才进行释放，如果数据库有一个长事务，可能就会导致大量的线程被阻塞到。

申请MDL锁的操作会形成一个队列，队列中的写锁获取优先级高于读锁，一旦出现MDL写锁等待，就会阻塞后续该表的所有CRUD操作

### 意向锁

意向锁的目的是为了快速判断表里是否有记录被加锁，如果没有意向锁，那么加独占表锁时，就需要遍历表里的所有记录，查看是否有记录存在独占锁，这样效率会很慢

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突

可以理解为要对表中的某一行加行锁，那么就可以对表先加一个意向共享锁，表示这个表或者某一行已经被加了读锁

> 意向锁的颗粒度会不会太大了？
> 如果使用了意向锁，即使只是修改表中的一行，那其他的事务也不能访问该表了

### AUTO-INC 锁

表中通常会有一个自增主键，在插入数据时，可以不指定主键的值，数据库可以自动给主键赋值递增的值，主要是通过 AUTO-INC 实现的

在执行插入语句时就加一个表级别的 AUTO-INC 锁，然后为每条待插入记录的AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把 AUTO-INC  释放掉

AUTO-INC锁以特殊的表锁机制，锁不是在一个事务提交之后才释放，而是在执行完插入语句后就会立即释放，但是在插入大量的数据时，会影响插入的性能，因为另一个事务中的插入会被阻塞。

InnoDB后来实现了一个轻量级的锁，在主键自增完之后就会立即释放

## 行级锁

行锁释放的时机是在事务提交之后

### 行锁的注意事项

- 行锁必须有索引才能实现，否则会自动锁全表，那就不是行锁了
- 如果是共享锁，两个事务可以锁同一个索引，排他锁则不能
- Insert、delete、update 在事务中会自动默认加上排他锁

### Record Lock

记录锁，也是一种读写锁

### Gap Lock

间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

> 假如表中有一个范围id为 (3, 5) 间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效防止幻读现象的发生

间隙锁也是读写锁，但是它的读写锁是没有什么区别的，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。

给一条记录加gap锁只是不允许其他事务向这条记录前的间隙插入新的记录，如何确保最后一条记录之后的记录不被插入数据？
给索引中最后一条记录所在页面的Supermum记录加上一个gap锁

### Next-Key Lock

临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身，是左开右闭的

相同范围的间隙锁是多个事务相互兼容的，但是对于记录锁，读写是冲突的

> 这个是每次只能锁住一条记录吗？

### 插入意向锁

一个事务在插入一条记录的时候，需要判断插入的位置是否已经被其他事务加了间隙锁，如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止，在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新纪录，但是现在处于等待状态

插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级别锁

插入意向锁和间隙锁的区别：两个事务不能在同一个时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁

> MySQL加锁的方式是先生成锁结构，然后再判断锁的状态是正常状态，还是等待状态，如果是等待状态，说明其他事务持有了一个与本事务冲突的锁结构，所以此插入意向锁的状态是等待状态，意味着没有成功获取插入意向锁

## 不同情况下的加锁

如果加锁的对象是索引，加锁的基本单位就是 Next-Key Lock

在能使用记录锁或间隙锁就能避免幻读的情况下，Next-Key Lock 就会退化成记录锁或间隙锁

**对于边界是开区间的 next-key lock 会退化成间隙锁，其他情况不会退化**

### 唯一索引等值查询

- 当查询的记录是**存在**的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成**记录锁**
	- 因为在唯一索引等值查询并且查询记录唯一的情况下，仅靠记录锁也能避免幻读的现象
	- 主键唯一，当其他事务进行插入时就会因为主键冲突而失败
	- 加了记录锁后，其他事务就无法删除该记录了
- 当查询的记录是**不存在**的，在索引树找到第一条记录大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成**间隙锁**
	- 如果继续是 next-key lock 那么其他事务就无法操作后边的记录了，并且我们只需要保证查找的主键不被插入就可以了，所以只用一个间隙锁就可以解决问题

### 唯一索引范围查询

当唯一索引进行范围查询的时候，会对每一个扫描到的索引加 next-key lock，然后如果遇到下面的情况，会退化成记录锁或间隙锁
- 针对**大于等于**的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中的，那么该记录的索引中的 next-key lock 就会退化成记录锁
	- 因为左边界是等值查询，并且 next-key lock 是左开右闭的，所以左边界变成了记录锁
- 针对**小于或小于等于**的范围查询，要看条件值的记录是否存在于表中
	- 当条件值的记录**不在表中**，那么不管是小于还是小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-ley lock 会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key lock
	- 当条件值的记录**在表中**，如果是**小于**条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key lock 会**退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key lock，如果**小于等于**条件的范围查询，扫描到终止范围查询的时候，该记录的索引 next-key lock **不会退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key lock

### 非唯一索引等值查询

当用非唯一索引进行等值查询的时候，存在两个索引，一个是主键索引，另一个是非唯一索引，所以在加锁时，同时会对这两个索引都加锁，但是对主键加锁的时候，只有满足查询条件的记录才会对他们的主键索引加锁

- 当查询的记录**存在**时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key lock，而对于第一个不符合条件的二级索引记录，该二级索引记录的 next-key lock 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁
- 当查询的记录不存在时，扫描到的第一条不符合条件的二级索引记录，该二级索引的 next-key lock 会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键进行加锁

### 非唯一索引范围查询

不会出现退化为间隙锁和记录锁的情况

### 没有加索引的查询

如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。

## 如何避免全表扫描导致业务停止

update
- 使用 where，并且 where 条件中必须有索引列
- 使用 limit
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

delete
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

## Insert 如何加行级锁

Insert在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为**隐式锁**来保护记录的

> 隐式锁：当事务需要加锁时，如果这个锁不可能发生冲突，InnoDB会跳过加锁的环节，这种机制称为隐式锁。隐式锁是InnoDB实现的一种延迟加锁的机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统的整体性能
>
> 将隐式锁转为显式锁的情况：
> - 如果记录之间加油间隙锁，为了避免幻读，此时是不能插入记录的
> - 如果Insert的记录和已有的记录存在唯一键冲突，此时也不能插入记录

## 如何避免死锁

- 设置事务等待锁的超时时间
- 开启主动死锁检测，主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行

## 乐观锁和悲观锁的原理以及应用场景

悲观锁先获取锁，然后再进行业务操作，一般就是利用类似 SELECT ... FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。当数据库执行 SELECT ... FOR UPDATE 时会获取被SELECT中的数据的行锁，获取的行锁会在事务结束是自动释放†

乐观锁是先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。