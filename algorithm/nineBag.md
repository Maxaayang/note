1. 01背包：每件物品最多用一次
2. 完全背包：每件物品有无限个
3. 多重背包：每个物品的个数不一样
4. 分组背包：物品有n组，每一组里面有若干种，每一组最多选一个物品
5. 二维费用背包问题：
6. 混合背包：
7. 背包问题求方案数：
8. 求背包问题的方案
9. 有依赖的背包问题

-   状态表示 f(i, j)
-   集合：所有选法
-   条件：只从前i个物品种选、总体积<=j
-   属性
-   状态计算：集合的划分

DP优化一般是对代码或方程做一个等价变形

# 背包问题

## 01背包
```C++
/*
    f[i][j] 表示只看前i个物品，总体积是j的情况下，总价值最大是多少
    result = max{f[n][0~v]}
    f[i][j]:
    1. 不选第 i 个物品， f[i][j] = f[i - 1][j]
    2. 选第 i 个物品， f[i][j] = f[i - 1][j - v[i]] + w[i]
    
    f[i][j] = max{1. 2.}
    f[0][0] = 0
    
    为什么从大到小枚举？
    保证转移的时候，用的是 f[i - 1][j - v[i]]
*/

    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= v[i]; j--) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= m; j++) P{
			f[i][j] = f[i - 1][j];
			if (j >= v[i]) {
				f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
			}
		}
	}

	// 如果求体积恰好是 m 时，最大价值是多少
	f[0] = 0;
	f[i] = -INF;
```

## 完全背包问题
```C++
/*
    f[i] 表示总体积是i的情况下最大价值是多少
    result = max{f[0 ... m]}
    
    为什么从小到大枚举可以保证每个物品被用无限次？
*/

    for (int i = 0; i < n; i++) {
        for (int j = v[i]; j <= m; j++) 
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    }

/*
    数学归纳法：
    1. 假设考虑前i-1个物品之后，所有的f[j]都是正确的
    2. 证明：考虑完第i个物品后，所有的f[j]也都是正确的
*/
```





